{"ast":null,"code":"/* eslint no-console: 0 */\n\n'use strict';\n\nconst urllib = require('url');\nconst util = require('util');\nconst fs = require('fs');\nconst nmfetch = require('../fetch');\nconst dns = require('dns');\nconst net = require('net');\nconst os = require('os');\nconst DNS_TTL = 5 * 60 * 1000;\nlet networkInterfaces;\ntry {\n  networkInterfaces = os.networkInterfaces();\n} catch (err) {\n  // fails on some systems\n}\nmodule.exports.networkInterfaces = networkInterfaces;\nconst isFamilySupported = (family, allowInternal) => {\n  let networkInterfaces = module.exports.networkInterfaces;\n  if (!networkInterfaces) {\n    // hope for the best\n    return true;\n  }\n  const familySupported =\n  // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6\n  Object.keys(networkInterfaces).map(key => networkInterfaces[key])\n  // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)\n  .reduce((acc, val) => acc.concat(val), []).filter(i => !i.internal || allowInternal).filter(i => i.family === 'IPv' + family || i.family === family).length > 0;\n  return familySupported;\n};\nconst resolver = (family, hostname, options, callback) => {\n  options = options || {};\n  const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);\n  if (!familySupported) {\n    return callback(null, []);\n  }\n  const resolver = dns.Resolver ? new dns.Resolver(options) : dns;\n  resolver['resolve' + family](hostname, (err, addresses) => {\n    if (err) {\n      switch (err.code) {\n        case dns.NODATA:\n        case dns.NOTFOUND:\n        case dns.NOTIMP:\n        case dns.SERVFAIL:\n        case dns.CONNREFUSED:\n        case dns.REFUSED:\n        case 'EAI_AGAIN':\n          return callback(null, []);\n      }\n      return callback(err);\n    }\n    return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n  });\n};\nconst dnsCache = module.exports.dnsCache = new Map();\nconst formatDNSValue = (value, extra) => {\n  if (!value) {\n    return Object.assign({}, extra || {});\n  }\n  return Object.assign({\n    servername: value.servername,\n    host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]\n  }, extra || {});\n};\nmodule.exports.resolveHostname = (options, callback) => {\n  options = options || {};\n  if (!options.host && options.servername) {\n    options.host = options.servername;\n  }\n  if (!options.host || net.isIP(options.host)) {\n    // nothing to do here\n    let value = {\n      addresses: [options.host],\n      servername: options.servername || false\n    };\n    return callback(null, formatDNSValue(value, {\n      cached: false\n    }));\n  }\n  let cached;\n  if (dnsCache.has(options.host)) {\n    cached = dnsCache.get(options.host);\n    if (!cached.expires || cached.expires >= Date.now()) {\n      return callback(null, formatDNSValue(cached.value, {\n        cached: true\n      }));\n    }\n  }\n  resolver(4, options.host, options, (err, addresses) => {\n    if (err) {\n      if (cached) {\n        // ignore error, use expired value\n        return callback(null, formatDNSValue(cached.value, {\n          cached: true,\n          error: err\n        }));\n      }\n      return callback(err);\n    }\n    if (addresses && addresses.length) {\n      let value = {\n        addresses,\n        servername: options.servername || options.host\n      };\n      dnsCache.set(options.host, {\n        value,\n        expires: Date.now() + (options.dnsTtl || DNS_TTL)\n      });\n      return callback(null, formatDNSValue(value, {\n        cached: false\n      }));\n    }\n    resolver(6, options.host, options, (err, addresses) => {\n      if (err) {\n        if (cached) {\n          // ignore error, use expired value\n          return callback(null, formatDNSValue(cached.value, {\n            cached: true,\n            error: err\n          }));\n        }\n        return callback(err);\n      }\n      if (addresses && addresses.length) {\n        let value = {\n          addresses,\n          servername: options.servername || options.host\n        };\n        dnsCache.set(options.host, {\n          value,\n          expires: Date.now() + (options.dnsTtl || DNS_TTL)\n        });\n        return callback(null, formatDNSValue(value, {\n          cached: false\n        }));\n      }\n      try {\n        dns.lookup(options.host, {\n          all: true\n        }, (err, addresses) => {\n          if (err) {\n            if (cached) {\n              // ignore error, use expired value\n              return callback(null, formatDNSValue(cached.value, {\n                cached: true,\n                error: err\n              }));\n            }\n            return callback(err);\n          }\n          let address = addresses ? addresses.filter(addr => isFamilySupported(addr.family)).map(addr => addr.address).shift() : false;\n          if (addresses && addresses.length && !address) {\n            // there are addresses but none can be used\n            console.warn(`Failed to resolve IPv${addresses[0].family} addresses with current network`);\n          }\n          if (!address && cached) {\n            // nothing was found, fallback to cached value\n            return callback(null, formatDNSValue(cached.value, {\n              cached: true\n            }));\n          }\n          let value = {\n            addresses: address ? [address] : [options.host],\n            servername: options.servername || options.host\n          };\n          dnsCache.set(options.host, {\n            value,\n            expires: Date.now() + (options.dnsTtl || DNS_TTL)\n          });\n          return callback(null, formatDNSValue(value, {\n            cached: false\n          }));\n        });\n      } catch (err) {\n        if (cached) {\n          // ignore error, use expired value\n          return callback(null, formatDNSValue(cached.value, {\n            cached: true,\n            error: err\n          }));\n        }\n        return callback(err);\n      }\n    });\n  });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n  str = str || '';\n  let options = {};\n  [urllib.parse(str, true)].forEach(url => {\n    let auth;\n    switch (url.protocol) {\n      case 'smtp:':\n        options.secure = false;\n        break;\n      case 'smtps:':\n        options.secure = true;\n        break;\n      case 'direct:':\n        options.direct = true;\n        break;\n    }\n    if (!isNaN(url.port) && Number(url.port)) {\n      options.port = Number(url.port);\n    }\n    if (url.hostname) {\n      options.host = url.hostname;\n    }\n    if (url.auth) {\n      auth = url.auth.split(':');\n      if (!options.auth) {\n        options.auth = {};\n      }\n      options.auth.user = auth.shift();\n      options.auth.pass = auth.join(':');\n    }\n    Object.keys(url.query || {}).forEach(key => {\n      let obj = options;\n      let lKey = key;\n      let value = url.query[key];\n      if (!isNaN(value)) {\n        value = Number(value);\n      }\n      switch (value) {\n        case 'true':\n          value = true;\n          break;\n        case 'false':\n          value = false;\n          break;\n      }\n\n      // tls is nested object\n      if (key.indexOf('tls.') === 0) {\n        lKey = key.substr(4);\n        if (!options.tls) {\n          options.tls = {};\n        }\n        obj = options.tls;\n      } else if (key.indexOf('.') >= 0) {\n        // ignore nested properties besides tls\n        return;\n      }\n      if (!(lKey in obj)) {\n        obj[lKey] = value;\n      }\n    });\n  });\n  return options;\n};\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n  let entry = {};\n  Object.keys(defaults || {}).forEach(key => {\n    if (key !== 'level') {\n      entry[key] = defaults[key];\n    }\n  });\n  Object.keys(data || {}).forEach(key => {\n    if (key !== 'level') {\n      entry[key] = data[key];\n    }\n  });\n  logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n  options = options || {};\n  let response = {};\n  let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n  if (!options.logger) {\n    // use vanity logger\n    levels.forEach(level => {\n      response[level] = () => false;\n    });\n    return response;\n  }\n  let logger = options.logger;\n  if (options.logger === true) {\n    // create console logger\n    logger = createDefaultLogger(levels);\n  }\n  levels.forEach(level => {\n    response[level] = (data, message, ...args) => {\n      module.exports._logFunc(logger, level, defaults, data, message, ...args);\n    };\n  });\n  return response;\n};\n\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) => function () {\n  let args = Array.from(arguments);\n  let err = args.shift();\n  if (err) {\n    reject(err);\n  } else {\n    resolve(...args);\n  }\n};\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n  let promise;\n  if (!callback) {\n    promise = new Promise((resolve, reject) => {\n      callback = module.exports.callbackPromise(resolve, reject);\n    });\n  }\n  let content = data && data[key] && data[key].content || data[key];\n  let contentStream;\n  let encoding = (typeof data[key] === 'object' && data[key].encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n  if (!content) {\n    return callback(null, content);\n  }\n  if (typeof content === 'object') {\n    if (typeof content.pipe === 'function') {\n      return resolveStream(content, (err, value) => {\n        if (err) {\n          return callback(err);\n        }\n        // we can't stream twice the same content, so we need\n        // to replace the stream object with the streaming result\n        if (data[key].content) {\n          data[key].content = value;\n        } else {\n          data[key] = value;\n        }\n        callback(null, value);\n      });\n    } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n      contentStream = nmfetch(content.path || content.href);\n      return resolveStream(contentStream, callback);\n    } else if (/^data:/i.test(content.path || content.href)) {\n      let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n      if (!parts) {\n        return callback(null, Buffer.from(0));\n      }\n      return callback(null, /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2])));\n    } else if (content.path) {\n      return resolveStream(fs.createReadStream(content.path), callback);\n    }\n  }\n  if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n    content = Buffer.from(data[key].content, encoding);\n  }\n\n  // default action, return as is\n  setImmediate(() => callback(null, content));\n  return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function /* target, ... sources */\n() {\n  let args = Array.from(arguments);\n  let target = args.shift() || {};\n  args.forEach(source => {\n    Object.keys(source || {}).forEach(key => {\n      if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n        // tls and auth are special keys that need to be enumerated separately\n        // other objects are passed as is\n        if (!target[key]) {\n          // ensure that target has this key\n          target[key] = {};\n        }\n        Object.keys(source[key]).forEach(subKey => {\n          target[key][subKey] = source[key][subKey];\n        });\n      } else {\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n};\nmodule.exports.encodeXText = str => {\n  // ! 0x21\n  // + 0x2B\n  // = 0x3D\n  // ~ 0x7E\n  if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n    return str;\n  }\n  let buf = Buffer.from(str);\n  let result = '';\n  for (let i = 0, len = buf.length; i < len; i++) {\n    let c = buf[i];\n    if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n      result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n    } else {\n      result += String.fromCharCode(c);\n    }\n  }\n  return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n  let responded = false;\n  let chunks = [];\n  let chunklen = 0;\n  stream.on('error', err => {\n    if (responded) {\n      return;\n    }\n    responded = true;\n    callback(err);\n  });\n  stream.on('readable', () => {\n    let chunk;\n    while ((chunk = stream.read()) !== null) {\n      chunks.push(chunk);\n      chunklen += chunk.length;\n    }\n  });\n  stream.on('end', () => {\n    if (responded) {\n      return;\n    }\n    responded = true;\n    let value;\n    try {\n      value = Buffer.concat(chunks, chunklen);\n    } catch (E) {\n      return callback(E);\n    }\n    callback(null, value);\n  });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n  let levelMaxLen = 0;\n  let levelNames = new Map();\n  levels.forEach(level => {\n    if (level.length > levelMaxLen) {\n      levelMaxLen = level.length;\n    }\n  });\n  levels.forEach(level => {\n    let levelName = level.toUpperCase();\n    if (levelName.length < levelMaxLen) {\n      levelName += ' '.repeat(levelMaxLen - levelName.length);\n    }\n    levelNames.set(level, levelName);\n  });\n  let print = (level, entry, message, ...args) => {\n    let prefix = '';\n    if (entry) {\n      if (entry.tnx === 'server') {\n        prefix = 'S: ';\n      } else if (entry.tnx === 'client') {\n        prefix = 'C: ';\n      }\n      if (entry.sid) {\n        prefix = '[' + entry.sid + '] ' + prefix;\n      }\n      if (entry.cid) {\n        prefix = '[#' + entry.cid + '] ' + prefix;\n      }\n    }\n    message = util.format(message, ...args);\n    message.split(/\\r?\\n/).forEach(line => {\n      console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n    });\n  };\n  let logger = {};\n  levels.forEach(level => {\n    logger[level] = print.bind(null, level);\n  });\n  return logger;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}