{"ast":null,"code":"/* eslint no-undefined: 0 */\n\n'use strict';\n\nconst MimeNode = require('../mime-node');\nconst mimeFuncs = require('../mime-funcs');\n\n/**\n * Creates the object for composing a MimeNode instance out from the mail options\n *\n * @constructor\n * @param {Object} mail Mail options\n */\nclass MailComposer {\n  constructor(mail) {\n    this.mail = mail || {};\n    this.message = false;\n  }\n\n  /**\n   * Builds MimeNode instance\n   */\n  compile() {\n    this._alternatives = this.getAlternatives();\n    this._htmlNode = this._alternatives.filter(alternative => /^text\\/html\\b/i.test(alternative.contentType)).pop();\n    this._attachments = this.getAttachments(!!this._htmlNode);\n    this._useRelated = !!(this._htmlNode && this._attachments.related.length);\n    this._useAlternative = this._alternatives.length > 1;\n    this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1;\n\n    // Compose MIME tree\n    if (this.mail.raw) {\n      this.message = new MimeNode('message/rfc822', {\n        newline: this.mail.newline\n      }).setRaw(this.mail.raw);\n    } else if (this._useMixed) {\n      this.message = this._createMixed();\n    } else if (this._useAlternative) {\n      this.message = this._createAlternative();\n    } else if (this._useRelated) {\n      this.message = this._createRelated();\n    } else {\n      this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {\n        contentType: 'text/plain',\n        content: ''\n      });\n    }\n\n    // Add custom headers\n    if (this.mail.headers) {\n      this.message.addHeader(this.mail.headers);\n    }\n\n    // Add headers to the root node, always overrides custom headers\n    ['from', 'sender', 'to', 'cc', 'bcc', 'reply-to', 'in-reply-to', 'references', 'subject', 'message-id', 'date'].forEach(header => {\n      let key = header.replace(/-(\\w)/g, (o, c) => c.toUpperCase());\n      if (this.mail[key]) {\n        this.message.setHeader(header, this.mail[key]);\n      }\n    });\n\n    // Sets custom envelope\n    if (this.mail.envelope) {\n      this.message.setEnvelope(this.mail.envelope);\n    }\n\n    // ensure Message-Id value\n    this.message.messageId();\n    return this.message;\n  }\n\n  /**\n   * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes\n   *\n   * @param {Boolean} findRelated If true separate related attachments from attached ones\n   * @returns {Object} An object of arrays (`related` and `attached`)\n   */\n  getAttachments(findRelated) {\n    let icalEvent, eventObject;\n    let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {\n      let data;\n      let isMessageNode = /^message\\//i.test(attachment.contentType);\n      if (/^data:/i.test(attachment.path || attachment.href)) {\n        attachment = this._processDataUrl(attachment);\n      }\n      data = {\n        contentType: attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin'),\n        contentDisposition: attachment.contentDisposition || (isMessageNode ? 'inline' : 'attachment'),\n        contentTransferEncoding: 'contentTransferEncoding' in attachment ? attachment.contentTransferEncoding : 'base64'\n      };\n      if (attachment.filename) {\n        data.filename = attachment.filename;\n      } else if (!isMessageNode && attachment.filename !== false) {\n        data.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);\n        if (data.filename.indexOf('.') < 0) {\n          data.filename += '.' + mimeFuncs.detectExtension(data.contentType);\n        }\n      }\n      if (/^https?:\\/\\//i.test(attachment.path)) {\n        attachment.href = attachment.path;\n        attachment.path = undefined;\n      }\n      if (attachment.cid) {\n        data.cid = attachment.cid;\n      }\n      if (attachment.raw) {\n        data.raw = attachment.raw;\n      } else if (attachment.path) {\n        data.content = {\n          path: attachment.path\n        };\n      } else if (attachment.href) {\n        data.content = {\n          href: attachment.href,\n          httpHeaders: attachment.httpHeaders\n        };\n      } else {\n        data.content = attachment.content || '';\n      }\n      if (attachment.encoding) {\n        data.encoding = attachment.encoding;\n      }\n      if (attachment.headers) {\n        data.headers = attachment.headers;\n      }\n      return data;\n    });\n    if (this.mail.icalEvent) {\n      if (typeof this.mail.icalEvent === 'object' && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {\n        icalEvent = this.mail.icalEvent;\n      } else {\n        icalEvent = {\n          content: this.mail.icalEvent\n        };\n      }\n      eventObject = {};\n      Object.keys(icalEvent).forEach(key => {\n        eventObject[key] = icalEvent[key];\n      });\n      eventObject.contentType = 'application/ics';\n      if (!eventObject.headers) {\n        eventObject.headers = {};\n      }\n      eventObject.filename = eventObject.filename || 'invite.ics';\n      eventObject.headers['Content-Disposition'] = 'attachment';\n      eventObject.headers['Content-Transfer-Encoding'] = 'base64';\n    }\n    if (!findRelated) {\n      return {\n        attached: attachments.concat(eventObject || []),\n        related: []\n      };\n    } else {\n      return {\n        attached: attachments.filter(attachment => !attachment.cid).concat(eventObject || []),\n        related: attachments.filter(attachment => !!attachment.cid)\n      };\n    }\n  }\n\n  /**\n   * List alternatives. Resulting objects can be used as input for MimeNode nodes\n   *\n   * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well\n   */\n  getAlternatives() {\n    let alternatives = [],\n      text,\n      html,\n      watchHtml,\n      amp,\n      icalEvent,\n      eventObject;\n    if (this.mail.text) {\n      if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {\n        text = this.mail.text;\n      } else {\n        text = {\n          content: this.mail.text\n        };\n      }\n      text.contentType = 'text/plain; charset=utf-8';\n    }\n    if (this.mail.watchHtml) {\n      if (typeof this.mail.watchHtml === 'object' && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {\n        watchHtml = this.mail.watchHtml;\n      } else {\n        watchHtml = {\n          content: this.mail.watchHtml\n        };\n      }\n      watchHtml.contentType = 'text/watch-html; charset=utf-8';\n    }\n    if (this.mail.amp) {\n      if (typeof this.mail.amp === 'object' && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {\n        amp = this.mail.amp;\n      } else {\n        amp = {\n          content: this.mail.amp\n        };\n      }\n      amp.contentType = 'text/x-amp-html; charset=utf-8';\n    }\n\n    // NB! when including attachments with a calendar alternative you might end up in a blank screen on some clients\n    if (this.mail.icalEvent) {\n      if (typeof this.mail.icalEvent === 'object' && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {\n        icalEvent = this.mail.icalEvent;\n      } else {\n        icalEvent = {\n          content: this.mail.icalEvent\n        };\n      }\n      eventObject = {};\n      Object.keys(icalEvent).forEach(key => {\n        eventObject[key] = icalEvent[key];\n      });\n      if (eventObject.content && typeof eventObject.content === 'object') {\n        // we are going to have the same attachment twice, so mark this to be\n        // resolved just once\n        eventObject.content._resolve = true;\n      }\n      eventObject.filename = false;\n      eventObject.contentType = 'text/calendar; charset=utf-8; method=' + (eventObject.method || 'PUBLISH').toString().trim().toUpperCase();\n      if (!eventObject.headers) {\n        eventObject.headers = {};\n      }\n    }\n    if (this.mail.html) {\n      if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {\n        html = this.mail.html;\n      } else {\n        html = {\n          content: this.mail.html\n        };\n      }\n      html.contentType = 'text/html; charset=utf-8';\n    }\n    [].concat(text || []).concat(watchHtml || []).concat(amp || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach(alternative => {\n      let data;\n      if (/^data:/i.test(alternative.path || alternative.href)) {\n        alternative = this._processDataUrl(alternative);\n      }\n      data = {\n        contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),\n        contentTransferEncoding: alternative.contentTransferEncoding\n      };\n      if (alternative.filename) {\n        data.filename = alternative.filename;\n      }\n      if (/^https?:\\/\\//i.test(alternative.path)) {\n        alternative.href = alternative.path;\n        alternative.path = undefined;\n      }\n      if (alternative.raw) {\n        data.raw = alternative.raw;\n      } else if (alternative.path) {\n        data.content = {\n          path: alternative.path\n        };\n      } else if (alternative.href) {\n        data.content = {\n          href: alternative.href\n        };\n      } else {\n        data.content = alternative.content || '';\n      }\n      if (alternative.encoding) {\n        data.encoding = alternative.encoding;\n      }\n      if (alternative.headers) {\n        data.headers = alternative.headers;\n      }\n      alternatives.push(data);\n    });\n    return alternatives;\n  }\n\n  /**\n   * Builds multipart/mixed node. It should always contain different type of elements on the same level\n   * eg. text + attachments\n   *\n   * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n   * @returns {Object} MimeNode node element\n   */\n  _createMixed(parentNode) {\n    let node;\n    if (!parentNode) {\n      node = new MimeNode('multipart/mixed', {\n        baseBoundary: this.mail.baseBoundary,\n        textEncoding: this.mail.textEncoding,\n        boundaryPrefix: this.mail.boundaryPrefix,\n        disableUrlAccess: this.mail.disableUrlAccess,\n        disableFileAccess: this.mail.disableFileAccess,\n        normalizeHeaderKey: this.mail.normalizeHeaderKey,\n        newline: this.mail.newline\n      });\n    } else {\n      node = parentNode.createChild('multipart/mixed', {\n        disableUrlAccess: this.mail.disableUrlAccess,\n        disableFileAccess: this.mail.disableFileAccess,\n        normalizeHeaderKey: this.mail.normalizeHeaderKey,\n        newline: this.mail.newline\n      });\n    }\n    if (this._useAlternative) {\n      this._createAlternative(node);\n    } else if (this._useRelated) {\n      this._createRelated(node);\n    }\n    [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach(element => {\n      // if the element is a html node from related subpart then ignore it\n      if (!this._useRelated || element !== this._htmlNode) {\n        this._createContentNode(node, element);\n      }\n    });\n    return node;\n  }\n\n  /**\n   * Builds multipart/alternative node. It should always contain same type of elements on the same level\n   * eg. text + html view of the same data\n   *\n   * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n   * @returns {Object} MimeNode node element\n   */\n  _createAlternative(parentNode) {\n    let node;\n    if (!parentNode) {\n      node = new MimeNode('multipart/alternative', {\n        baseBoundary: this.mail.baseBoundary,\n        textEncoding: this.mail.textEncoding,\n        boundaryPrefix: this.mail.boundaryPrefix,\n        disableUrlAccess: this.mail.disableUrlAccess,\n        disableFileAccess: this.mail.disableFileAccess,\n        normalizeHeaderKey: this.mail.normalizeHeaderKey,\n        newline: this.mail.newline\n      });\n    } else {\n      node = parentNode.createChild('multipart/alternative', {\n        disableUrlAccess: this.mail.disableUrlAccess,\n        disableFileAccess: this.mail.disableFileAccess,\n        normalizeHeaderKey: this.mail.normalizeHeaderKey,\n        newline: this.mail.newline\n      });\n    }\n    this._alternatives.forEach(alternative => {\n      if (this._useRelated && this._htmlNode === alternative) {\n        this._createRelated(node);\n      } else {\n        this._createContentNode(node, alternative);\n      }\n    });\n    return node;\n  }\n\n  /**\n   * Builds multipart/related node. It should always contain html node with related attachments\n   *\n   * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n   * @returns {Object} MimeNode node element\n   */\n  _createRelated(parentNode) {\n    let node;\n    if (!parentNode) {\n      node = new MimeNode('multipart/related; type=\"text/html\"', {\n        baseBoundary: this.mail.baseBoundary,\n        textEncoding: this.mail.textEncoding,\n        boundaryPrefix: this.mail.boundaryPrefix,\n        disableUrlAccess: this.mail.disableUrlAccess,\n        disableFileAccess: this.mail.disableFileAccess,\n        normalizeHeaderKey: this.mail.normalizeHeaderKey,\n        newline: this.mail.newline\n      });\n    } else {\n      node = parentNode.createChild('multipart/related; type=\"text/html\"', {\n        disableUrlAccess: this.mail.disableUrlAccess,\n        disableFileAccess: this.mail.disableFileAccess,\n        normalizeHeaderKey: this.mail.normalizeHeaderKey,\n        newline: this.mail.newline\n      });\n    }\n    this._createContentNode(node, this._htmlNode);\n    this._attachments.related.forEach(alternative => this._createContentNode(node, alternative));\n    return node;\n  }\n\n  /**\n   * Creates a regular node with contents\n   *\n   * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created\n   * @param {Object} element Node data\n   * @returns {Object} MimeNode node element\n   */\n  _createContentNode(parentNode, element) {\n    element = element || {};\n    element.content = element.content || '';\n    let node;\n    let encoding = (element.encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n    if (!parentNode) {\n      node = new MimeNode(element.contentType, {\n        filename: element.filename,\n        baseBoundary: this.mail.baseBoundary,\n        textEncoding: this.mail.textEncoding,\n        boundaryPrefix: this.mail.boundaryPrefix,\n        disableUrlAccess: this.mail.disableUrlAccess,\n        disableFileAccess: this.mail.disableFileAccess,\n        normalizeHeaderKey: this.mail.normalizeHeaderKey,\n        newline: this.mail.newline\n      });\n    } else {\n      node = parentNode.createChild(element.contentType, {\n        filename: element.filename,\n        textEncoding: this.mail.textEncoding,\n        disableUrlAccess: this.mail.disableUrlAccess,\n        disableFileAccess: this.mail.disableFileAccess,\n        normalizeHeaderKey: this.mail.normalizeHeaderKey,\n        newline: this.mail.newline\n      });\n    }\n\n    // add custom headers\n    if (element.headers) {\n      node.addHeader(element.headers);\n    }\n    if (element.cid) {\n      node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');\n    }\n    if (element.contentTransferEncoding) {\n      node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);\n    } else if (this.mail.encoding && /^text\\//i.test(element.contentType)) {\n      node.setHeader('Content-Transfer-Encoding', this.mail.encoding);\n    }\n    if (!/^text\\//i.test(element.contentType) || element.contentDisposition) {\n      node.setHeader('Content-Disposition', element.contentDisposition || (element.cid ? 'inline' : 'attachment'));\n    }\n    if (typeof element.content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n      element.content = Buffer.from(element.content, encoding);\n    }\n\n    // prefer pregenerated raw content\n    if (element.raw) {\n      node.setRaw(element.raw);\n    } else {\n      node.setContent(element.content);\n    }\n    return node;\n  }\n\n  /**\n   * Parses data uri and converts it to a Buffer\n   *\n   * @param {Object} element Content element\n   * @return {Object} Parsed element\n   */\n  _processDataUrl(element) {\n    let parts = (element.path || element.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);\n    if (!parts) {\n      return element;\n    }\n    element.content = /\\bbase64$/i.test(parts[1]) ? Buffer.from(parts[2], 'base64') : Buffer.from(decodeURIComponent(parts[2]));\n    if ('path' in element) {\n      element.path = false;\n    }\n    if ('href' in element) {\n      element.href = false;\n    }\n    parts[1].split(';').forEach(item => {\n      if (/^\\w+\\/[^/]+$/i.test(item)) {\n        element.contentType = element.contentType || item.toLowerCase();\n      }\n    });\n    return element;\n  }\n}\nmodule.exports = MailComposer;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}