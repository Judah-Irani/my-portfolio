{"ast":null,"code":"'use strict';\n\nvar http = require('http');\nvar https = require('https');\nvar url = require('url');\nvar util = require('util');\nvar stream = require('stream');\nvar zlib = require('zlib');\nvar aws2 = require('aws-sign2');\nvar aws4 = require('aws4');\nvar httpSignature = require('http-signature');\nvar mime = require('mime-types');\nvar caseless = require('caseless');\nvar ForeverAgent = require('forever-agent');\nvar FormData = require('form-data');\nvar extend = require('extend');\nvar isstream = require('isstream');\nvar isTypedArray = require('is-typedarray').strict;\nvar helpers = require('./lib/helpers');\nvar cookies = require('./lib/cookies');\nvar getProxyFromURI = require('./lib/getProxyFromURI');\nvar Querystring = require('./lib/querystring').Querystring;\nvar Har = require('./lib/har').Har;\nvar Auth = require('./lib/auth').Auth;\nvar OAuth = require('./lib/oauth').OAuth;\nvar hawk = require('./lib/hawk');\nvar Multipart = require('./lib/multipart').Multipart;\nvar Redirect = require('./lib/redirect').Redirect;\nvar Tunnel = require('./lib/tunnel').Tunnel;\nvar now = require('performance-now');\nvar Buffer = require('safe-buffer').Buffer;\nvar safeStringify = helpers.safeStringify;\nvar isReadStream = helpers.isReadStream;\nvar toBase64 = helpers.toBase64;\nvar defer = helpers.defer;\nvar copy = helpers.copy;\nvar version = helpers.version;\nvar globalCookieJar = cookies.jar();\nvar globalPool = {};\nfunction filterForNonReserved(reserved, options) {\n  // Filter out properties that are not reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {};\n  for (var i in options) {\n    var notReserved = reserved.indexOf(i) === -1;\n    if (notReserved) {\n      object[i] = options[i];\n    }\n  }\n  return object;\n}\nfunction filterOutReservedFunctions(reserved, options) {\n  // Filter out properties that are functions and are reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {};\n  for (var i in options) {\n    var isReserved = !(reserved.indexOf(i) === -1);\n    var isFunction = typeof options[i] === 'function';\n    if (!(isReserved && isFunction)) {\n      object[i] = options[i];\n    }\n  }\n  return object;\n}\n\n// Return a simpler request object to allow serialization\nfunction requestToJSON() {\n  var self = this;\n  return {\n    uri: self.uri,\n    method: self.method,\n    headers: self.headers\n  };\n}\n\n// Return a simpler response object to allow serialization\nfunction responseToJSON() {\n  var self = this;\n  return {\n    statusCode: self.statusCode,\n    body: self.body,\n    headers: self.headers,\n    request: requestToJSON.call(self.request)\n  };\n}\nfunction Request(options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this;\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self);\n    options = self._har.options(options);\n  }\n  stream.Stream.call(self);\n  var reserved = Object.keys(Request.prototype);\n  var nonReserved = filterForNonReserved(reserved, options);\n  extend(self, nonReserved);\n  options = filterOutReservedFunctions(reserved, options);\n  self.readable = true;\n  self.writable = true;\n  if (options.method) {\n    self.explicitMethod = true;\n  }\n  self._qs = new Querystring(self);\n  self._auth = new Auth(self);\n  self._oauth = new OAuth(self);\n  self._multipart = new Multipart(self);\n  self._redirect = new Redirect(self);\n  self._tunnel = new Tunnel(self);\n  self.init(options);\n}\nutil.inherits(Request, stream.Stream);\n\n// Debugging\nRequest.debug = process.env.NODE_DEBUG && /\\brequest\\b/.test(process.env.NODE_DEBUG);\nfunction debug() {\n  if (Request.debug) {\n    console.error('REQUEST %s', util.format.apply(util, arguments));\n  }\n}\nRequest.prototype.debug = debug;\nRequest.prototype.init = function (options) {\n  // init() contains all the code to setup the request object.\n  // the actual outgoing request is not started until start() is called\n  // this function is called from both the constructor and on redirect.\n  var self = this;\n  if (!options) {\n    options = {};\n  }\n  self.headers = self.headers ? copy(self.headers) : {};\n\n  // Delete headers with value undefined since they break\n  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n  for (var headerName in self.headers) {\n    if (typeof self.headers[headerName] === 'undefined') {\n      delete self.headers[headerName];\n    }\n  }\n  caseless.httpify(self, self.headers);\n  if (!self.method) {\n    self.method = options.method || 'GET';\n  }\n  if (!self.localAddress) {\n    self.localAddress = options.localAddress;\n  }\n  self._qs.init(options);\n  debug(options);\n  if (!self.pool && self.pool !== false) {\n    self.pool = globalPool;\n  }\n  self.dests = self.dests || [];\n  self.__isRequestRequest = true;\n\n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback;\n    self.callback = function () {\n      if (self._callbackCalled) {\n        return; // Print a warning maybe?\n      }\n\n      self._callbackCalled = true;\n      self._callback.apply(self, arguments);\n    };\n    self.on('error', self.callback.bind());\n    self.on('complete', self.callback.bind(self, null));\n  }\n\n  // People use this property instead all the time, so support it\n  if (!self.uri && self.url) {\n    self.uri = self.url;\n    delete self.url;\n  }\n\n  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n  // specified as a relative path and is appended to baseUrl).\n  if (self.baseUrl) {\n    if (typeof self.baseUrl !== 'string') {\n      return self.emit('error', new Error('options.baseUrl must be a string'));\n    }\n    if (typeof self.uri !== 'string') {\n      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'));\n    }\n    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'));\n    }\n\n    // Handle all cases to make sure that there's only one slash between\n    // baseUrl and uri.\n    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1;\n    var uriStartsWithSlash = self.uri.indexOf('/') === 0;\n    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri.slice(1);\n    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri;\n    } else if (self.uri === '') {\n      self.uri = self.baseUrl;\n    } else {\n      self.uri = self.baseUrl + '/' + self.uri;\n    }\n    delete self.baseUrl;\n  }\n\n  // A URI is needed by this point, emit error if we haven't been able to get one\n  if (!self.uri) {\n    return self.emit('error', new Error('options.uri is a required argument'));\n  }\n\n  // If a string URI/URL was given, parse it into a URL object\n  if (typeof self.uri === 'string') {\n    self.uri = url.parse(self.uri);\n  }\n\n  // Some URL objects are not from a URL parsed string and need href added\n  if (!self.uri.href) {\n    self.uri.href = url.format(self.uri);\n  }\n\n  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n  if (self.uri.protocol === 'unix:') {\n    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'));\n  }\n\n  // Support Unix Sockets\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket();\n  }\n  if (self.strictSSL === false) {\n    self.rejectUnauthorized = false;\n  }\n  if (!self.uri.pathname) {\n    self.uri.pathname = '/';\n  }\n  if (!(self.uri.host || self.uri.hostname && self.uri.port) && !self.uri.isUnix) {\n    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri);\n    var message = 'Invalid URI \"' + faultyUri + '\"';\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n      // they should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.';\n    }\n    // This error was fatal\n    self.abort();\n    return self.emit('error', new Error(message));\n  }\n  if (!self.hasOwnProperty('proxy')) {\n    self.proxy = getProxyFromURI(self.uri);\n  }\n  self.tunnel = self._tunnel.isEnabled();\n  if (self.proxy) {\n    self._tunnel.setup(options);\n  }\n  self._redirect.onRequest(options);\n  self.setHost = false;\n  if (!self.hasHeader('host')) {\n    var hostHeaderName = self.originalHostHeaderName || 'host';\n    self.setHeader(hostHeaderName, self.uri.host);\n    // Drop :port suffix from Host header if known protocol.\n    if (self.uri.port) {\n      if (self.uri.port === '80' && self.uri.protocol === 'http:' || self.uri.port === '443' && self.uri.protocol === 'https:') {\n        self.setHeader(hostHeaderName, self.uri.hostname);\n      }\n    }\n    self.setHost = true;\n  }\n  self.jar(self._jar || options.jar);\n  if (!self.uri.port) {\n    if (self.uri.protocol === 'http:') {\n      self.uri.port = 80;\n    } else if (self.uri.protocol === 'https:') {\n      self.uri.port = 443;\n    }\n  }\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port;\n    self.host = self.proxy.hostname;\n  } else {\n    self.port = self.uri.port;\n    self.host = self.uri.hostname;\n  }\n  if (options.form) {\n    self.form(options.form);\n  }\n  if (options.formData) {\n    var formData = options.formData;\n    var requestForm = self.form();\n    var appendFormValue = function (key, value) {\n      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n        requestForm.append(key, value.value, value.options);\n      } else {\n        requestForm.append(key, value);\n      }\n    };\n    for (var formKey in formData) {\n      if (formData.hasOwnProperty(formKey)) {\n        var formValue = formData[formKey];\n        if (formValue instanceof Array) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n    }\n  }\n  if (options.qs) {\n    self.qs(options.qs);\n  }\n  if (self.uri.path) {\n    self.path = self.uri.path;\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || '');\n  }\n  if (self.path.length === 0) {\n    self.path = '/';\n  }\n\n  // Auth must happen last in case signing is dependent on other headers\n  if (options.aws) {\n    self.aws(options.aws);\n  }\n  if (options.hawk) {\n    self.hawk(options.hawk);\n  }\n  if (options.httpSignature) {\n    self.httpSignature(options.httpSignature);\n  }\n  if (options.auth) {\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n      options.auth.user = options.auth.username;\n    }\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n      options.auth.pass = options.auth.password;\n    }\n    self.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer);\n  }\n  if (self.gzip && !self.hasHeader('accept-encoding')) {\n    self.setHeader('accept-encoding', 'gzip, deflate');\n  }\n  if (self.uri.auth && !self.hasHeader('authorization')) {\n    var uriAuthPieces = self.uri.auth.split(':').map(function (item) {\n      return self._qs.unescape(item);\n    });\n    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true);\n  }\n  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) {\n      return self._qs.unescape(item);\n    });\n    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'));\n    self.setHeader('proxy-authorization', authHeader);\n  }\n  if (self.proxy && !self.tunnel) {\n    self.path = self.uri.protocol + '//' + self.uri.host + self.path;\n  }\n  if (options.json) {\n    self.json(options.json);\n  }\n  if (options.multipart) {\n    self.multipart(options.multipart);\n  }\n  if (options.time) {\n    self.timing = true;\n\n    // NOTE: elapsedTime is deprecated in favor of .timings\n    self.elapsedTime = self.elapsedTime || 0;\n  }\n  function setContentLength() {\n    if (isTypedArray(self.body)) {\n      self.body = Buffer.from(self.body);\n    }\n    if (!self.hasHeader('content-length')) {\n      var length;\n      if (typeof self.body === 'string') {\n        length = Buffer.byteLength(self.body);\n      } else if (Array.isArray(self.body)) {\n        length = self.body.reduce(function (a, b) {\n          return a + b.length;\n        }, 0);\n      } else {\n        length = self.body.length;\n      }\n      if (length) {\n        self.setHeader('content-length', length);\n      } else {\n        self.emit('error', new Error('Argument error, options.body.'));\n      }\n    }\n  }\n  if (self.body && !isstream(self.body)) {\n    setContentLength();\n  }\n  if (options.oauth) {\n    self.oauth(options.oauth);\n  } else if (self._oauth.params && self.hasHeader('authorization')) {\n    self.oauth(self._oauth.params);\n  }\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol;\n  var defaultModules = {\n    'http:': http,\n    'https:': https\n  };\n  var httpModules = self.httpModules || {};\n  self.httpModule = httpModules[protocol] || defaultModules[protocol];\n  if (!self.httpModule) {\n    return self.emit('error', new Error('Invalid protocol: ' + protocol));\n  }\n  if (options.ca) {\n    self.ca = options.ca;\n  }\n  if (!self.agent) {\n    if (options.agentOptions) {\n      self.agentOptions = options.agentOptions;\n    }\n    if (options.agentClass) {\n      self.agentClass = options.agentClass;\n    } else if (options.forever) {\n      var v = version();\n      // use ForeverAgent in node 0.10- only\n      if (v.major === 0 && v.minor <= 10) {\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL;\n      } else {\n        self.agentClass = self.httpModule.Agent;\n        self.agentOptions = self.agentOptions || {};\n        self.agentOptions.keepAlive = true;\n      }\n    } else {\n      self.agentClass = self.httpModule.Agent;\n    }\n  }\n  if (self.pool === false) {\n    self.agent = false;\n  } else {\n    self.agent = self.agent || self.getNewAgent();\n  }\n  self.on('pipe', function (src) {\n    if (self.ntick && self._started) {\n      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'));\n    }\n    self.src = src;\n    if (isReadStream(src)) {\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', mime.lookup(src.path));\n      }\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.hasHeader(i)) {\n            self.setHeader(i, src.headers[i]);\n          }\n        }\n      }\n      if (self._json && !self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json');\n      }\n      if (src.method && !self.explicitMethod) {\n        self.method = src.method;\n      }\n    }\n\n    // self.on('pipe', function () {\n    //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n    // })\n  });\n\n  defer(function () {\n    if (self._aborted) {\n      return;\n    }\n    var end = function () {\n      if (self._form) {\n        if (!self._auth.hasAuth) {\n          self._form.pipe(self);\n        } else if (self._auth.hasAuth && self._auth.sentAuth) {\n          self._form.pipe(self);\n        }\n      }\n      if (self._multipart && self._multipart.chunked) {\n        self._multipart.body.pipe(self);\n      }\n      if (self.body) {\n        if (isstream(self.body)) {\n          self.body.pipe(self);\n        } else {\n          setContentLength();\n          if (Array.isArray(self.body)) {\n            self.body.forEach(function (part) {\n              self.write(part);\n            });\n          } else {\n            self.write(self.body);\n          }\n          self.end();\n        }\n      } else if (self.requestBodyStream) {\n        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.');\n        self.requestBodyStream.pipe(self);\n      } else if (!self.src) {\n        if (self._auth.hasAuth && !self._auth.sentAuth) {\n          self.end();\n          return;\n        }\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n          self.setHeader('content-length', 0);\n        }\n        self.end();\n      }\n    };\n    if (self._form && !self.hasHeader('content-length')) {\n      // Before ending the request, we had to compute the length of the whole form, asyncly\n      self.setHeader(self._form.getHeaders(), true);\n      self._form.getLength(function (err, length) {\n        if (!err && !isNaN(length)) {\n          self.setHeader('content-length', length);\n        }\n        end();\n      });\n    } else {\n      end();\n    }\n    self.ntick = true;\n  });\n};\nRequest.prototype.getNewAgent = function () {\n  var self = this;\n  var Agent = self.agentClass;\n  var options = {};\n  if (self.agentOptions) {\n    for (var i in self.agentOptions) {\n      options[i] = self.agentOptions[i];\n    }\n  }\n  if (self.ca) {\n    options.ca = self.ca;\n  }\n  if (self.ciphers) {\n    options.ciphers = self.ciphers;\n  }\n  if (self.secureProtocol) {\n    options.secureProtocol = self.secureProtocol;\n  }\n  if (self.secureOptions) {\n    options.secureOptions = self.secureOptions;\n  }\n  if (typeof self.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = self.rejectUnauthorized;\n  }\n  if (self.cert && self.key) {\n    options.key = self.key;\n    options.cert = self.cert;\n  }\n  if (self.pfx) {\n    options.pfx = self.pfx;\n  }\n  if (self.passphrase) {\n    options.passphrase = self.passphrase;\n  }\n  var poolKey = '';\n\n  // different types of agents are in different pools\n  if (Agent !== self.httpModule.Agent) {\n    poolKey += Agent.name;\n  }\n\n  // ca option is only relevant if proxy or destination are https\n  var proxy = self.proxy;\n  if (typeof proxy === 'string') {\n    proxy = url.parse(proxy);\n  }\n  var isHttps = proxy && proxy.protocol === 'https:' || this.uri.protocol === 'https:';\n  if (isHttps) {\n    if (options.ca) {\n      if (poolKey) {\n        poolKey += ':';\n      }\n      poolKey += options.ca;\n    }\n    if (typeof options.rejectUnauthorized !== 'undefined') {\n      if (poolKey) {\n        poolKey += ':';\n      }\n      poolKey += options.rejectUnauthorized;\n    }\n    if (options.cert) {\n      if (poolKey) {\n        poolKey += ':';\n      }\n      poolKey += options.cert.toString('ascii') + options.key.toString('ascii');\n    }\n    if (options.pfx) {\n      if (poolKey) {\n        poolKey += ':';\n      }\n      poolKey += options.pfx.toString('ascii');\n    }\n    if (options.ciphers) {\n      if (poolKey) {\n        poolKey += ':';\n      }\n      poolKey += options.ciphers;\n    }\n    if (options.secureProtocol) {\n      if (poolKey) {\n        poolKey += ':';\n      }\n      poolKey += options.secureProtocol;\n    }\n    if (options.secureOptions) {\n      if (poolKey) {\n        poolKey += ':';\n      }\n      poolKey += options.secureOptions;\n    }\n  }\n  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return self.httpModule.globalAgent;\n  }\n\n  // we're using a stored agent.  Make sure it's protocol-specific\n  poolKey = self.uri.protocol + poolKey;\n\n  // generate a new agent for this setting if none yet exists\n  if (!self.pool[poolKey]) {\n    self.pool[poolKey] = new Agent(options);\n    // properly set maxSockets on new agents\n    if (self.pool.maxSockets) {\n      self.pool[poolKey].maxSockets = self.pool.maxSockets;\n    }\n  }\n  return self.pool[poolKey];\n};\nRequest.prototype.start = function () {\n  // start() is called once we are ready to send the outgoing HTTP request.\n  // this is usually called on the first write(), end() or on nextTick()\n  var self = this;\n  if (self.timing) {\n    // All timings will be relative to this request's startTime.  In order to do this,\n    // we need to capture the wall-clock start time (via Date), immediately followed\n    // by the high-resolution timer (via now()).  While these two won't be set\n    // at the _exact_ same time, they should be close enough to be able to calculate\n    // high-resolution, monotonically non-decreasing timestamps relative to startTime.\n    var startTime = new Date().getTime();\n    var startTimeNow = now();\n  }\n  if (self._aborted) {\n    return;\n  }\n  self._started = true;\n  self.method = self.method || 'GET';\n  self.href = self.uri.href;\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n    self.setHeader('content-length', self.src.stat.size);\n  }\n  if (self._aws) {\n    self.aws(self._aws, true);\n  }\n\n  // We have a method named auth, which is completely different from the http.request\n  // auth option.  If we don't remove it, we're gonna have a bad time.\n  var reqOptions = copy(self);\n  delete reqOptions.auth;\n  debug('make request', self.uri.href);\n\n  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we\n  // should delete it for now since we handle timeouts manually for better\n  // consistency with node versions before v6.8.0\n  delete reqOptions.timeout;\n  try {\n    self.req = self.httpModule.request(reqOptions);\n  } catch (err) {\n    self.emit('error', err);\n    return;\n  }\n  if (self.timing) {\n    self.startTime = startTime;\n    self.startTimeNow = startTimeNow;\n\n    // Timing values will all be relative to startTime (by comparing to startTimeNow\n    // so we have an accurate clock)\n    self.timings = {};\n  }\n  var timeout;\n  if (self.timeout && !self.timeoutTimer) {\n    if (self.timeout < 0) {\n      timeout = 0;\n    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {\n      timeout = self.timeout;\n    }\n  }\n  self.req.on('response', self.onRequestResponse.bind(self));\n  self.req.on('error', self.onRequestError.bind(self));\n  self.req.on('drain', function () {\n    self.emit('drain');\n  });\n  self.req.on('socket', function (socket) {\n    // `._connecting` was the old property which was made public in node v6.1.0\n    var isConnecting = socket._connecting || socket.connecting;\n    if (self.timing) {\n      self.timings.socket = now() - self.startTimeNow;\n      if (isConnecting) {\n        var onLookupTiming = function () {\n          self.timings.lookup = now() - self.startTimeNow;\n        };\n        var onConnectTiming = function () {\n          self.timings.connect = now() - self.startTimeNow;\n        };\n        socket.once('lookup', onLookupTiming);\n        socket.once('connect', onConnectTiming);\n\n        // clean up timing event listeners if needed on error\n        self.req.once('error', function () {\n          socket.removeListener('lookup', onLookupTiming);\n          socket.removeListener('connect', onConnectTiming);\n        });\n      }\n    }\n    var setReqTimeout = function () {\n      // This timeout sets the amount of time to wait *between* bytes sent\n      // from the server once connected.\n      //\n      // In particular, it's useful for erroring if the server fails to send\n      // data halfway through streaming a response.\n      self.req.setTimeout(timeout, function () {\n        if (self.req) {\n          self.abort();\n          var e = new Error('ESOCKETTIMEDOUT');\n          e.code = 'ESOCKETTIMEDOUT';\n          e.connect = false;\n          self.emit('error', e);\n        }\n      });\n    };\n    if (timeout !== undefined) {\n      // Only start the connection timer if we're actually connecting a new\n      // socket, otherwise if we're already connected (because this is a\n      // keep-alive connection) do not bother. This is important since we won't\n      // get a 'connect' event for an already connected socket.\n      if (isConnecting) {\n        var onReqSockConnect = function () {\n          socket.removeListener('connect', onReqSockConnect);\n          self.clearTimeout();\n          setReqTimeout();\n        };\n        socket.on('connect', onReqSockConnect);\n        self.req.on('error', function (err) {\n          // eslint-disable-line handle-callback-err\n          socket.removeListener('connect', onReqSockConnect);\n        });\n\n        // Set a timeout in memory - this block will throw if the server takes more\n        // than `timeout` to write the HTTP status and headers (corresponding to\n        // the on('response') event on the client). NB: this measures wall-clock\n        // time, not the time between bytes sent by the server.\n        self.timeoutTimer = setTimeout(function () {\n          socket.removeListener('connect', onReqSockConnect);\n          self.abort();\n          var e = new Error('ETIMEDOUT');\n          e.code = 'ETIMEDOUT';\n          e.connect = true;\n          self.emit('error', e);\n        }, timeout);\n      } else {\n        // We're already connected\n        setReqTimeout();\n      }\n    }\n    self.emit('socket', socket);\n  });\n  self.emit('request', self.req);\n};\nRequest.prototype.onRequestError = function (error) {\n  var self = this;\n  if (self._aborted) {\n    return;\n  }\n  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' && self.agent.addRequestNoreuse) {\n    self.agent = {\n      addRequest: self.agent.addRequestNoreuse.bind(self.agent)\n    };\n    self.start();\n    self.req.end();\n    return;\n  }\n  self.clearTimeout();\n  self.emit('error', error);\n};\nRequest.prototype.onRequestResponse = function (response) {\n  var self = this;\n  if (self.timing) {\n    self.timings.response = now() - self.startTimeNow;\n  }\n  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers);\n  response.on('end', function () {\n    if (self.timing) {\n      self.timings.end = now() - self.startTimeNow;\n      response.timingStart = self.startTime;\n\n      // fill in the blanks for any periods that didn't trigger, such as\n      // no lookup or connect due to keep alive\n      if (!self.timings.socket) {\n        self.timings.socket = 0;\n      }\n      if (!self.timings.lookup) {\n        self.timings.lookup = self.timings.socket;\n      }\n      if (!self.timings.connect) {\n        self.timings.connect = self.timings.lookup;\n      }\n      if (!self.timings.response) {\n        self.timings.response = self.timings.connect;\n      }\n      debug('elapsed time', self.timings.end);\n\n      // elapsedTime includes all redirects\n      self.elapsedTime += Math.round(self.timings.end);\n\n      // NOTE: elapsedTime is deprecated in favor of .timings\n      response.elapsedTime = self.elapsedTime;\n\n      // timings is just for the final fetch\n      response.timings = self.timings;\n\n      // pre-calculate phase timings as well\n      response.timingPhases = {\n        wait: self.timings.socket,\n        dns: self.timings.lookup - self.timings.socket,\n        tcp: self.timings.connect - self.timings.lookup,\n        firstByte: self.timings.response - self.timings.connect,\n        download: self.timings.end - self.timings.response,\n        total: self.timings.end\n      };\n    }\n    debug('response end', self.uri.href, response.statusCode, response.headers);\n  });\n  if (self._aborted) {\n    debug('aborted', self.uri.href);\n    response.resume();\n    return;\n  }\n  self.response = response;\n  response.request = self;\n  response.toJSON = responseToJSON;\n\n  // XXX This is different on 0.10, because SSL is strict by default\n  if (self.httpModule === https && self.strictSSL && (!response.hasOwnProperty('socket') || !response.socket.authorized)) {\n    debug('strict ssl error', self.uri.href);\n    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL';\n    self.emit('error', new Error('SSL Error: ' + sslErr));\n    return;\n  }\n\n  // Save the original host before any redirect (if it changes, we need to\n  // remove any authorization headers).  Also remember the case of the header\n  // name because lots of broken servers expect Host instead of host and we\n  // want the caller to be able to specify this.\n  self.originalHost = self.getHeader('host');\n  if (!self.originalHostHeaderName) {\n    self.originalHostHeaderName = self.hasHeader('host');\n  }\n  if (self.setHost) {\n    self.removeHeader('host');\n  }\n  self.clearTimeout();\n  var targetCookieJar = self._jar && self._jar.setCookie ? self._jar : globalCookieJar;\n  var addCookie = function (cookie) {\n    // set the cookie if it's domain in the href's domain.\n    try {\n      targetCookieJar.setCookie(cookie, self.uri.href, {\n        ignoreError: true\n      });\n    } catch (e) {\n      self.emit('error', e);\n    }\n  };\n  response.caseless = caseless(response.headers);\n  if (response.caseless.has('set-cookie') && !self._disableCookies) {\n    var headerName = response.caseless.has('set-cookie');\n    if (Array.isArray(response.headers[headerName])) {\n      response.headers[headerName].forEach(addCookie);\n    } else {\n      addCookie(response.headers[headerName]);\n    }\n  }\n  if (self._redirect.onResponse(response)) {\n    return; // Ignore the rest of the response\n  } else {\n    // Be a good stream and emit end when the response is finished.\n    // Hack to emit end on close because of a core bug that never fires end\n    response.on('close', function () {\n      if (!self._ended) {\n        self.response.emit('end');\n      }\n    });\n    response.once('end', function () {\n      self._ended = true;\n    });\n    var noBody = function (code) {\n      return self.method === 'HEAD' ||\n      // Informational\n      code >= 100 && code < 200 ||\n      // No Content\n      code === 204 ||\n      // Not Modified\n      code === 304;\n    };\n    var responseContent;\n    if (self.gzip && !noBody(response.statusCode)) {\n      var contentEncoding = response.headers['content-encoding'] || 'identity';\n      contentEncoding = contentEncoding.trim().toLowerCase();\n\n      // Be more lenient with decoding compressed responses, since (very rarely)\n      // servers send slightly invalid gzip responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      var zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      };\n      if (contentEncoding === 'gzip') {\n        responseContent = zlib.createGunzip(zlibOptions);\n        response.pipe(responseContent);\n      } else if (contentEncoding === 'deflate') {\n        responseContent = zlib.createInflate(zlibOptions);\n        response.pipe(responseContent);\n      } else {\n        // Since previous versions didn't check for Content-Encoding header,\n        // ignore any invalid values to preserve backwards-compatibility\n        if (contentEncoding !== 'identity') {\n          debug('ignoring unrecognized Content-Encoding ' + contentEncoding);\n        }\n        responseContent = response;\n      }\n    } else {\n      responseContent = response;\n    }\n    if (self.encoding) {\n      if (self.dests.length !== 0) {\n        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.');\n      } else {\n        responseContent.setEncoding(self.encoding);\n      }\n    }\n    if (self._paused) {\n      responseContent.pause();\n    }\n    self.responseContent = responseContent;\n    self.emit('response', response);\n    self.dests.forEach(function (dest) {\n      self.pipeDest(dest);\n    });\n    responseContent.on('data', function (chunk) {\n      if (self.timing && !self.responseStarted) {\n        self.responseStartTime = new Date().getTime();\n\n        // NOTE: responseStartTime is deprecated in favor of .timings\n        response.responseStartTime = self.responseStartTime;\n      }\n      self._destdata = true;\n      self.emit('data', chunk);\n    });\n    responseContent.once('end', function (chunk) {\n      self.emit('end', chunk);\n    });\n    responseContent.on('error', function (error) {\n      self.emit('error', error);\n    });\n    responseContent.on('close', function () {\n      self.emit('close');\n    });\n    if (self.callback) {\n      self.readResponseBody(response);\n    } else {\n      // if no callback\n      self.on('end', function () {\n        if (self._aborted) {\n          debug('aborted', self.uri.href);\n          return;\n        }\n        self.emit('complete', response);\n      });\n    }\n  }\n  debug('finish init function', self.uri.href);\n};\nRequest.prototype.readResponseBody = function (response) {\n  var self = this;\n  debug(\"reading response's body\");\n  var buffers = [];\n  var bufferLength = 0;\n  var strings = [];\n  self.on('data', function (chunk) {\n    if (!Buffer.isBuffer(chunk)) {\n      strings.push(chunk);\n    } else if (chunk.length) {\n      bufferLength += chunk.length;\n      buffers.push(chunk);\n    }\n  });\n  self.on('end', function () {\n    debug('end event', self.uri.href);\n    if (self._aborted) {\n      debug('aborted', self.uri.href);\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = [];\n      bufferLength = 0;\n      return;\n    }\n    if (bufferLength) {\n      debug('has body', self.uri.href, bufferLength);\n      response.body = Buffer.concat(buffers, bufferLength);\n      if (self.encoding !== null) {\n        response.body = response.body.toString(self.encoding);\n      }\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = [];\n      bufferLength = 0;\n    } else if (strings.length) {\n      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n        strings[0] = strings[0].substring(1);\n      }\n      response.body = strings.join('');\n    }\n    if (self._json) {\n      try {\n        response.body = JSON.parse(response.body, self._jsonReviver);\n      } catch (e) {\n        debug('invalid JSON received', self.uri.href);\n      }\n    }\n    debug('emitting complete', self.uri.href);\n    if (typeof response.body === 'undefined' && !self._json) {\n      response.body = self.encoding === null ? Buffer.alloc(0) : '';\n    }\n    self.emit('complete', response, response.body);\n  });\n};\nRequest.prototype.abort = function () {\n  var self = this;\n  self._aborted = true;\n  if (self.req) {\n    self.req.abort();\n  } else if (self.response) {\n    self.response.destroy();\n  }\n  self.clearTimeout();\n  self.emit('abort');\n};\nRequest.prototype.pipeDest = function (dest) {\n  var self = this;\n  var response = self.response;\n  // Called after the response is received\n  if (dest.headers && !dest.headersSent) {\n    if (response.caseless.has('content-type')) {\n      var ctname = response.caseless.has('content-type');\n      if (dest.setHeader) {\n        dest.setHeader(ctname, response.headers[ctname]);\n      } else {\n        dest.headers[ctname] = response.headers[ctname];\n      }\n    }\n    if (response.caseless.has('content-length')) {\n      var clname = response.caseless.has('content-length');\n      if (dest.setHeader) {\n        dest.setHeader(clname, response.headers[clname]);\n      } else {\n        dest.headers[clname] = response.headers[clname];\n      }\n    }\n  }\n  if (dest.setHeader && !dest.headersSent) {\n    for (var i in response.headers) {\n      // If the response content is being decoded, the Content-Encoding header\n      // of the response doesn't represent the piped content, so don't pass it.\n      if (!self.gzip || i !== 'content-encoding') {\n        dest.setHeader(i, response.headers[i]);\n      }\n    }\n    dest.statusCode = response.statusCode;\n  }\n  if (self.pipefilter) {\n    self.pipefilter(response, dest);\n  }\n};\nRequest.prototype.qs = function (q, clobber) {\n  var self = this;\n  var base;\n  if (!clobber && self.uri.query) {\n    base = self._qs.parse(self.uri.query);\n  } else {\n    base = {};\n  }\n  for (var i in q) {\n    base[i] = q[i];\n  }\n  var qs = self._qs.stringify(base);\n  if (qs === '') {\n    return self;\n  }\n  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs);\n  self.url = self.uri;\n  self.path = self.uri.path;\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket();\n  }\n  return self;\n};\nRequest.prototype.form = function (form) {\n  var self = this;\n  if (form) {\n    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n      self.setHeader('content-type', 'application/x-www-form-urlencoded');\n    }\n    self.body = typeof form === 'string' ? self._qs.rfc3986(form.toString('utf8')) : self._qs.stringify(form).toString('utf8');\n    return self;\n  }\n  // create form-data object\n  self._form = new FormData();\n  self._form.on('error', function (err) {\n    err.message = 'form-data: ' + err.message;\n    self.emit('error', err);\n    self.abort();\n  });\n  return self._form;\n};\nRequest.prototype.multipart = function (multipart) {\n  var self = this;\n  self._multipart.onRequest(multipart);\n  if (!self._multipart.chunked) {\n    self.body = self._multipart.body;\n  }\n  return self;\n};\nRequest.prototype.json = function (val) {\n  var self = this;\n  if (!self.hasHeader('accept')) {\n    self.setHeader('accept', 'application/json');\n  }\n  if (typeof self.jsonReplacer === 'function') {\n    self._jsonReplacer = self.jsonReplacer;\n  }\n  self._json = true;\n  if (typeof val === 'boolean') {\n    if (self.body !== undefined) {\n      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n        self.body = safeStringify(self.body, self._jsonReplacer);\n      } else {\n        self.body = self._qs.rfc3986(self.body);\n      }\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json');\n      }\n    }\n  } else {\n    self.body = safeStringify(val, self._jsonReplacer);\n    if (!self.hasHeader('content-type')) {\n      self.setHeader('content-type', 'application/json');\n    }\n  }\n  if (typeof self.jsonReviver === 'function') {\n    self._jsonReviver = self.jsonReviver;\n  }\n  return self;\n};\nRequest.prototype.getHeader = function (name, headers) {\n  var self = this;\n  var result, re, match;\n  if (!headers) {\n    headers = self.headers;\n  }\n  Object.keys(headers).forEach(function (key) {\n    if (key.length !== name.length) {\n      return;\n    }\n    re = new RegExp(name, 'i');\n    match = key.match(re);\n    if (match) {\n      result = headers[key];\n    }\n  });\n  return result;\n};\nRequest.prototype.enableUnixSocket = function () {\n  // Get the socket & request paths from the URL\n  var unixParts = this.uri.path.split(':');\n  var host = unixParts[0];\n  var path = unixParts[1];\n  // Apply unix properties to request\n  this.socketPath = host;\n  this.uri.pathname = path;\n  this.uri.path = path;\n  this.uri.host = host;\n  this.uri.hostname = host;\n  this.uri.isUnix = true;\n};\nRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n  var self = this;\n  self._auth.onRequest(user, pass, sendImmediately, bearer);\n  return self;\n};\nRequest.prototype.aws = function (opts, now) {\n  var self = this;\n  if (!now) {\n    self._aws = opts;\n    return self;\n  }\n  if (opts.sign_version === 4 || opts.sign_version === '4') {\n    // use aws4\n    var options = {\n      host: self.uri.host,\n      path: self.uri.path,\n      method: self.method,\n      headers: self.headers,\n      body: self.body\n    };\n    if (opts.service) {\n      options.service = opts.service;\n    }\n    var signRes = aws4.sign(options, {\n      accessKeyId: opts.key,\n      secretAccessKey: opts.secret,\n      sessionToken: opts.session\n    });\n    self.setHeader('authorization', signRes.headers.Authorization);\n    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date']);\n    if (signRes.headers['X-Amz-Security-Token']) {\n      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token']);\n    }\n  } else {\n    // default: use aws-sign2\n    var date = new Date();\n    self.setHeader('date', date.toUTCString());\n    var auth = {\n      key: opts.key,\n      secret: opts.secret,\n      verb: self.method.toUpperCase(),\n      date: date,\n      contentType: self.getHeader('content-type') || '',\n      md5: self.getHeader('content-md5') || '',\n      amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n    };\n    var path = self.uri.path;\n    if (opts.bucket && path) {\n      auth.resource = '/' + opts.bucket + path;\n    } else if (opts.bucket && !path) {\n      auth.resource = '/' + opts.bucket;\n    } else if (!opts.bucket && path) {\n      auth.resource = path;\n    } else if (!opts.bucket && !path) {\n      auth.resource = '/';\n    }\n    auth.resource = aws2.canonicalizeResource(auth.resource);\n    self.setHeader('authorization', aws2.authorization(auth));\n  }\n  return self;\n};\nRequest.prototype.httpSignature = function (opts) {\n  var self = this;\n  httpSignature.signRequest({\n    getHeader: function (header) {\n      return self.getHeader(header, self.headers);\n    },\n    setHeader: function (header, value) {\n      self.setHeader(header, value);\n    },\n    method: self.method,\n    path: self.path\n  }, opts);\n  debug('httpSignature authorization', self.getHeader('authorization'));\n  return self;\n};\nRequest.prototype.hawk = function (opts) {\n  var self = this;\n  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts));\n};\nRequest.prototype.oauth = function (_oauth) {\n  var self = this;\n  self._oauth.onRequest(_oauth);\n  return self;\n};\nRequest.prototype.jar = function (jar) {\n  var self = this;\n  var cookies;\n  if (self._redirect.redirectsFollowed === 0) {\n    self.originalCookieHeader = self.getHeader('cookie');\n  }\n  if (!jar) {\n    // disable cookies\n    cookies = false;\n    self._disableCookies = true;\n  } else {\n    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;\n    var urihref = self.uri.href;\n    // fetch cookie in the Specified host\n    if (targetCookieJar) {\n      cookies = targetCookieJar.getCookieString(urihref);\n    }\n  }\n\n  // if need cookie and cookie is not empty\n  if (cookies && cookies.length) {\n    if (self.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies);\n    } else {\n      self.setHeader('cookie', cookies);\n    }\n  }\n  self._jar = jar;\n  return self;\n};\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  var self = this;\n  if (self.response) {\n    if (self._destdata) {\n      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'));\n    } else if (self._ended) {\n      self.emit('error', new Error('You cannot pipe after the response has been ended.'));\n    } else {\n      stream.Stream.prototype.pipe.call(self, dest, opts);\n      self.pipeDest(dest);\n      return dest;\n    }\n  } else {\n    self.dests.push(dest);\n    stream.Stream.prototype.pipe.call(self, dest, opts);\n    return dest;\n  }\n};\nRequest.prototype.write = function () {\n  var self = this;\n  if (self._aborted) {\n    return;\n  }\n  if (!self._started) {\n    self.start();\n  }\n  if (self.req) {\n    return self.req.write.apply(self.req, arguments);\n  }\n};\nRequest.prototype.end = function (chunk) {\n  var self = this;\n  if (self._aborted) {\n    return;\n  }\n  if (chunk) {\n    self.write(chunk);\n  }\n  if (!self._started) {\n    self.start();\n  }\n  if (self.req) {\n    self.req.end();\n  }\n};\nRequest.prototype.pause = function () {\n  var self = this;\n  if (!self.responseContent) {\n    self._paused = true;\n  } else {\n    self.responseContent.pause.apply(self.responseContent, arguments);\n  }\n};\nRequest.prototype.resume = function () {\n  var self = this;\n  if (!self.responseContent) {\n    self._paused = false;\n  } else {\n    self.responseContent.resume.apply(self.responseContent, arguments);\n  }\n};\nRequest.prototype.destroy = function () {\n  var self = this;\n  this.clearTimeout();\n  if (!self._ended) {\n    self.end();\n  } else if (self.response) {\n    self.response.destroy();\n  }\n};\nRequest.prototype.clearTimeout = function () {\n  if (this.timeoutTimer) {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n};\nRequest.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();\nRequest.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();\n\n// Exports\n\nRequest.prototype.toJSON = requestToJSON;\nmodule.exports = Request;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}