{"ast":null,"code":"/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst punycode = require('punycode');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\nconst mimeFuncs = require('../mime-funcs');\nconst qp = require('../qp');\nconst base64 = require('../base64');\nconst addressparser = require('../addressparser');\nconst nmfetch = require('../fetch');\nconst LastNewline = require('./last-newline');\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n  constructor(contentType, options) {\n    this.nodeCounter = 0;\n    options = options || {};\n\n    /**\n     * shared part of the unique multipart boundary\n     */\n    this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n    this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n    this.disableFileAccess = !!options.disableFileAccess;\n    this.disableUrlAccess = !!options.disableUrlAccess;\n    this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n    /**\n     * If date headers is missing and current node is the root, this value is used instead\n     */\n    this.date = new Date();\n\n    /**\n     * Root node for current mime tree\n     */\n    this.rootNode = options.rootNode || this;\n\n    /**\n     * If true include Bcc in generated headers (if available)\n     */\n    this.keepBcc = !!options.keepBcc;\n\n    /**\n     * If filename is specified but contentType is not (probably an attachment)\n     * detect the content type from filename extension\n     */\n    if (options.filename) {\n      /**\n       * Filename for this node. Useful with attachments\n       */\n      this.filename = options.filename;\n      if (!contentType) {\n        contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n      }\n    }\n\n    /**\n     * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n     */\n    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n    /**\n     * Immediate parent for this node (or undefined if not set)\n     */\n    this.parentNode = options.parentNode;\n\n    /**\n     * Hostname for default message-id values\n     */\n    this.hostname = options.hostname;\n\n    /**\n     * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n     */\n    this.newline = options.newline;\n\n    /**\n     * An array for possible child nodes\n     */\n    this.childNodes = [];\n\n    /**\n     * Used for generating unique boundaries (prepended to the shared base)\n     */\n    this._nodeId = ++this.rootNode.nodeCounter;\n\n    /**\n     * A list of header values for this node in the form of [{key:'', value:''}]\n     */\n    this._headers = [];\n\n    /**\n     * True if the content only uses ASCII printable characters\n     * @type {Boolean}\n     */\n    this._isPlainText = false;\n\n    /**\n     * True if the content is plain text but has longer lines than allowed\n     * @type {Boolean}\n     */\n    this._hasLongLines = false;\n\n    /**\n     * If set, use instead this value for envelopes instead of generating one\n     * @type {Boolean}\n     */\n    this._envelope = false;\n\n    /**\n     * If set then use this value as the stream content instead of building it\n     * @type {String|Buffer|Stream}\n     */\n    this._raw = false;\n\n    /**\n     * Additional transform streams that the message will be piped before\n     * exposing by createReadStream\n     * @type {Array}\n     */\n    this._transforms = [];\n\n    /**\n     * Additional process functions that the message will be piped through before\n     * exposing by createReadStream. These functions are run after transforms\n     * @type {Array}\n     */\n    this._processFuncs = [];\n\n    /**\n     * If content type is set (or derived from the filename) add it to headers\n     */\n    if (contentType) {\n      this.setHeader('Content-Type', contentType);\n    }\n  }\n\n  /////// PUBLIC METHODS\n\n  /**\n   * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n   *\n   * @param {String} [contentType] Optional content type\n   * @param {Object} [options] Optional options object\n   * @return {Object} Created node object\n   */\n  createChild(contentType, options) {\n    if (!options && typeof contentType === 'object') {\n      options = contentType;\n      contentType = undefined;\n    }\n    let node = new MimeNode(contentType, options);\n    this.appendChild(node);\n    return node;\n  }\n\n  /**\n   * Appends an existing node to the mime tree. Removes the node from an existing\n   * tree if needed\n   *\n   * @param {Object} childNode node to be appended\n   * @return {Object} Appended node object\n   */\n  appendChild(childNode) {\n    if (childNode.rootNode !== this.rootNode) {\n      childNode.rootNode = this.rootNode;\n      childNode._nodeId = ++this.rootNode.nodeCounter;\n    }\n    childNode.parentNode = this;\n    this.childNodes.push(childNode);\n    return childNode;\n  }\n\n  /**\n   * Replaces current node with another node\n   *\n   * @param {Object} node Replacement node\n   * @return {Object} Replacement node\n   */\n  replace(node) {\n    if (node === this) {\n      return this;\n    }\n    this.parentNode.childNodes.forEach((childNode, i) => {\n      if (childNode === this) {\n        node.rootNode = this.rootNode;\n        node.parentNode = this.parentNode;\n        node._nodeId = this._nodeId;\n        this.rootNode = this;\n        this.parentNode = undefined;\n        node.parentNode.childNodes[i] = node;\n      }\n    });\n    return node;\n  }\n\n  /**\n   * Removes current node from the mime tree\n   *\n   * @return {Object} removed node\n   */\n  remove() {\n    if (!this.parentNode) {\n      return this;\n    }\n    for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n      if (this.parentNode.childNodes[i] === this) {\n        this.parentNode.childNodes.splice(i, 1);\n        this.parentNode = undefined;\n        this.rootNode = this;\n        return this;\n      }\n    }\n  }\n\n  /**\n   * Sets a header value. If the value for selected key exists, it is overwritten.\n   * You can set multiple values as well by using [{key:'', value:''}] or\n   * {key: 'value'} as the first argument.\n   *\n   * @param {String|Array|Object} key Header key or a list of key value pairs\n   * @param {String} value Header value\n   * @return {Object} current node\n   */\n  setHeader(key, value) {\n    let added = false,\n      headerValue;\n\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n      // allow {key:'content-type', value: 'text/plain'}\n      if (key.key && 'value' in key) {\n        this.setHeader(key.key, key.value);\n      } else if (Array.isArray(key)) {\n        // allow [{key:'content-type', value: 'text/plain'}]\n        key.forEach(i => {\n          this.setHeader(i.key, i.value);\n        });\n      } else {\n        // allow {'content-type': 'text/plain'}\n        Object.keys(key).forEach(i => {\n          this.setHeader(i, key[i]);\n        });\n      }\n      return this;\n    }\n    key = this._normalizeHeaderKey(key);\n    headerValue = {\n      key,\n      value\n    };\n\n    // Check if the value exists and overwrite\n    for (let i = 0, len = this._headers.length; i < len; i++) {\n      if (this._headers[i].key === key) {\n        if (!added) {\n          // replace the first match\n          this._headers[i] = headerValue;\n          added = true;\n        } else {\n          // remove following matches\n          this._headers.splice(i, 1);\n          i--;\n          len--;\n        }\n      }\n    }\n\n    // match not found, append the value\n    if (!added) {\n      this._headers.push(headerValue);\n    }\n    return this;\n  }\n\n  /**\n   * Adds a header value. If the value for selected key exists, the value is appended\n   * as a new field and old one is not touched.\n   * You can set multiple values as well by using [{key:'', value:''}] or\n   * {key: 'value'} as the first argument.\n   *\n   * @param {String|Array|Object} key Header key or a list of key value pairs\n   * @param {String} value Header value\n   * @return {Object} current node\n   */\n  addHeader(key, value) {\n    // Allow setting multiple headers at once\n    if (!value && key && typeof key === 'object') {\n      // allow {key:'content-type', value: 'text/plain'}\n      if (key.key && key.value) {\n        this.addHeader(key.key, key.value);\n      } else if (Array.isArray(key)) {\n        // allow [{key:'content-type', value: 'text/plain'}]\n        key.forEach(i => {\n          this.addHeader(i.key, i.value);\n        });\n      } else {\n        // allow {'content-type': 'text/plain'}\n        Object.keys(key).forEach(i => {\n          this.addHeader(i, key[i]);\n        });\n      }\n      return this;\n    } else if (Array.isArray(value)) {\n      value.forEach(val => {\n        this.addHeader(key, val);\n      });\n      return this;\n    }\n    this._headers.push({\n      key: this._normalizeHeaderKey(key),\n      value\n    });\n    return this;\n  }\n\n  /**\n   * Retrieves the first mathcing value of a selected key\n   *\n   * @param {String} key Key to search for\n   * @retun {String} Value for the key\n   */\n  getHeader(key) {\n    key = this._normalizeHeaderKey(key);\n    for (let i = 0, len = this._headers.length; i < len; i++) {\n      if (this._headers[i].key === key) {\n        return this._headers[i].value;\n      }\n    }\n  }\n\n  /**\n   * Sets body content for current node. If the value is a string, charset is added automatically\n   * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n   * the charset yourself\n   *\n   * @param (String|Buffer) content Body content\n   * @return {Object} current node\n   */\n  setContent(content) {\n    this.content = content;\n    if (typeof this.content.pipe === 'function') {\n      // pre-stream handler. might be triggered if a stream is set as content\n      // and 'error' fires before anything is done with this stream\n      this._contentErrorHandler = err => {\n        this.content.removeListener('error', this._contentErrorHandler);\n        this.content = err;\n      };\n      this.content.once('error', this._contentErrorHandler);\n    } else if (typeof this.content === 'string') {\n      this._isPlainText = mimeFuncs.isPlainText(this.content);\n      if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n        // If there are lines longer than 76 symbols/bytes do not use 7bit\n        this._hasLongLines = true;\n      }\n    }\n    return this;\n  }\n  build(callback) {\n    let promise;\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n    let stream = this.createReadStream();\n    let buf = [];\n    let buflen = 0;\n    let returned = false;\n    stream.on('readable', () => {\n      let chunk;\n      while ((chunk = stream.read()) !== null) {\n        buf.push(chunk);\n        buflen += chunk.length;\n      }\n    });\n    stream.once('error', err => {\n      if (returned) {\n        return;\n      }\n      returned = true;\n      return callback(err);\n    });\n    stream.once('end', chunk => {\n      if (returned) {\n        return;\n      }\n      returned = true;\n      if (chunk && chunk.length) {\n        buf.push(chunk);\n        buflen += chunk.length;\n      }\n      return callback(null, Buffer.concat(buf, buflen));\n    });\n    return promise;\n  }\n  getTransferEncoding() {\n    let transferEncoding = false;\n    let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n    if (this.content) {\n      transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n      if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n        if (/^text\\//i.test(contentType)) {\n          // If there are no special symbols, no need to modify the text\n          if (this._isPlainText && !this._hasLongLines) {\n            transferEncoding = '7bit';\n          } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n            // detect preferred encoding for string value\n            transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n          } else {\n            // we can not check content for a stream, so either use preferred encoding or fallback to QP\n            transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n          }\n        } else if (!/^(multipart|message)\\//i.test(contentType)) {\n          transferEncoding = transferEncoding || 'base64';\n        }\n      }\n    }\n    return transferEncoding;\n  }\n\n  /**\n   * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n   *\n   * @returns {String} Headers\n   */\n  buildHeaders() {\n    let transferEncoding = this.getTransferEncoding();\n    let headers = [];\n    if (transferEncoding) {\n      this.setHeader('Content-Transfer-Encoding', transferEncoding);\n    }\n    if (this.filename && !this.getHeader('Content-Disposition')) {\n      this.setHeader('Content-Disposition', 'attachment');\n    }\n\n    // Ensure mandatory header fields\n    if (this.rootNode === this) {\n      if (!this.getHeader('Date')) {\n        this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n      }\n\n      // ensure that Message-Id is present\n      this.messageId();\n      if (!this.getHeader('MIME-Version')) {\n        this.setHeader('MIME-Version', '1.0');\n      }\n    }\n    this._headers.forEach(header => {\n      let key = header.key;\n      let value = header.value;\n      let structured;\n      let param;\n      let options = {};\n      let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n      if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n        Object.keys(value).forEach(key => {\n          if (key !== 'value') {\n            options[key] = value[key];\n          }\n        });\n        value = (value.value || '').toString();\n        if (!value.trim()) {\n          return;\n        }\n      }\n      if (options.prepared) {\n        // header value is\n        if (options.foldLines) {\n          headers.push(mimeFuncs.foldLines(key + ': ' + value));\n        } else {\n          headers.push(key + ': ' + value);\n        }\n        return;\n      }\n      switch (header.key) {\n        case 'Content-Disposition':\n          structured = mimeFuncs.parseHeaderValue(value);\n          if (this.filename) {\n            structured.params.filename = this.filename;\n          }\n          value = mimeFuncs.buildHeaderValue(structured);\n          break;\n        case 'Content-Type':\n          structured = mimeFuncs.parseHeaderValue(value);\n          this._handleContentType(structured);\n          if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n            structured.params.charset = 'utf-8';\n          }\n          value = mimeFuncs.buildHeaderValue(structured);\n          if (this.filename) {\n            // add support for non-compliant clients like QQ webmail\n            // we can't build the value with buildHeaderValue as the value is non standard and\n            // would be converted to parameter continuation encoding that we do not want\n            param = this._encodeWords(this.filename);\n            if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n              // include value in quotes if needed\n              param = '\"' + param + '\"';\n            }\n            value += '; name=' + param;\n          }\n          break;\n        case 'Bcc':\n          if (!this.keepBcc) {\n            // skip BCC values\n            return;\n          }\n          break;\n      }\n      value = this._encodeHeaderValue(key, value);\n\n      // skip empty lines\n      if (!(value || '').toString().trim()) {\n        return;\n      }\n      if (typeof this.normalizeHeaderKey === 'function') {\n        let normalized = this.normalizeHeaderKey(key, value);\n        if (normalized && typeof normalized === 'string' && normalized.length) {\n          key = normalized;\n        }\n      }\n      headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n    });\n    return headers.join('\\r\\n');\n  }\n\n  /**\n   * Streams the rfc2822 message from the current node. If this is a root node,\n   * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n   *\n   * @return {String} Compiled message\n   */\n  createReadStream(options) {\n    options = options || {};\n    let stream = new PassThrough(options);\n    let outputStream = stream;\n    let transform;\n    this.stream(stream, options, err => {\n      if (err) {\n        outputStream.emit('error', err);\n        return;\n      }\n      stream.end();\n    });\n    for (let i = 0, len = this._transforms.length; i < len; i++) {\n      transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n      outputStream.once('error', err => {\n        transform.emit('error', err);\n      });\n      outputStream = outputStream.pipe(transform);\n    }\n\n    // ensure terminating newline after possible user transforms\n    transform = new LastNewline();\n    outputStream.once('error', err => {\n      transform.emit('error', err);\n    });\n    outputStream = outputStream.pipe(transform);\n\n    // dkim and stuff\n    for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n      transform = this._processFuncs[i];\n      outputStream = transform(outputStream);\n    }\n    if (this.newline) {\n      const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n      const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n      const stream = outputStream.pipe(newlineTransform);\n      outputStream.on('error', err => stream.emit('error', err));\n      return stream;\n    }\n    return outputStream;\n  }\n\n  /**\n   * Appends a transform stream object to the transforms list. Final output\n   * is passed through this stream before exposing\n   *\n   * @param {Object} transform Read-Write stream\n   */\n  transform(transform) {\n    this._transforms.push(transform);\n  }\n\n  /**\n   * Appends a post process function. The functon is run after transforms and\n   * uses the following syntax\n   *\n   *   processFunc(input) -> outputStream\n   *\n   * @param {Object} processFunc Read-Write stream\n   */\n  processFunc(processFunc) {\n    this._processFuncs.push(processFunc);\n  }\n  stream(outputStream, options, done) {\n    let transferEncoding = this.getTransferEncoding();\n    let contentStream;\n    let localStream;\n\n    // protect actual callback against multiple triggering\n    let returned = false;\n    let callback = err => {\n      if (returned) {\n        return;\n      }\n      returned = true;\n      done(err);\n    };\n\n    // for multipart nodes, push child nodes\n    // for content nodes end the stream\n    let finalize = () => {\n      let childId = 0;\n      let processChildNode = () => {\n        if (childId >= this.childNodes.length) {\n          outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n          return callback();\n        }\n        let child = this.childNodes[childId++];\n        outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n        child.stream(outputStream, options, err => {\n          if (err) {\n            return callback(err);\n          }\n          setImmediate(processChildNode);\n        });\n      };\n      if (this.multipart) {\n        setImmediate(processChildNode);\n      } else {\n        return callback();\n      }\n    };\n\n    // pushes node content\n    let sendContent = () => {\n      if (this.content) {\n        if (Object.prototype.toString.call(this.content) === '[object Error]') {\n          // content is already errored\n          return callback(this.content);\n        }\n        if (typeof this.content.pipe === 'function') {\n          this.content.removeListener('error', this._contentErrorHandler);\n          this._contentErrorHandler = err => callback(err);\n          this.content.once('error', this._contentErrorHandler);\n        }\n        let createStream = () => {\n          if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n            contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n            contentStream.pipe(outputStream, {\n              end: false\n            });\n            contentStream.once('end', finalize);\n            contentStream.once('error', err => callback(err));\n            localStream = this._getStream(this.content);\n            localStream.pipe(contentStream);\n          } else {\n            // anything that is not QP or Base54 passes as-is\n            localStream = this._getStream(this.content);\n            localStream.pipe(outputStream, {\n              end: false\n            });\n            localStream.once('end', finalize);\n          }\n          localStream.once('error', err => callback(err));\n        };\n        if (this.content._resolve) {\n          let chunks = [];\n          let chunklen = 0;\n          let returned = false;\n          let sourceStream = this._getStream(this.content);\n          sourceStream.on('error', err => {\n            if (returned) {\n              return;\n            }\n            returned = true;\n            callback(err);\n          });\n          sourceStream.on('readable', () => {\n            let chunk;\n            while ((chunk = sourceStream.read()) !== null) {\n              chunks.push(chunk);\n              chunklen += chunk.length;\n            }\n          });\n          sourceStream.on('end', () => {\n            if (returned) {\n              return;\n            }\n            returned = true;\n            this.content._resolve = false;\n            this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n            setImmediate(createStream);\n          });\n        } else {\n          setImmediate(createStream);\n        }\n        return;\n      } else {\n        return setImmediate(finalize);\n      }\n    };\n    if (this._raw) {\n      setImmediate(() => {\n        if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n          // content is already errored\n          return callback(this._raw);\n        }\n\n        // remove default error handler (if set)\n        if (typeof this._raw.pipe === 'function') {\n          this._raw.removeListener('error', this._contentErrorHandler);\n        }\n        let raw = this._getStream(this._raw);\n        raw.pipe(outputStream, {\n          end: false\n        });\n        raw.on('error', err => outputStream.emit('error', err));\n        raw.on('end', finalize);\n      });\n    } else {\n      outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n      setImmediate(sendContent);\n    }\n  }\n\n  /**\n   * Sets envelope to be used instead of the generated one\n   *\n   * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n   */\n  setEnvelope(envelope) {\n    let list;\n    this._envelope = {\n      from: false,\n      to: []\n    };\n    if (envelope.from) {\n      list = [];\n      this._convertAddresses(this._parseAddresses(envelope.from), list);\n      list = list.filter(address => address && address.address);\n      if (list.length && list[0]) {\n        this._envelope.from = list[0].address;\n      }\n    }\n    ['to', 'cc', 'bcc'].forEach(key => {\n      if (envelope[key]) {\n        this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n      }\n    });\n    this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n    let standardFields = ['to', 'cc', 'bcc', 'from'];\n    Object.keys(envelope).forEach(key => {\n      if (!standardFields.includes(key)) {\n        this._envelope[key] = envelope[key];\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Generates and returns an object with parsed address fields\n   *\n   * @return {Object} Address object\n   */\n  getAddresses() {\n    let addresses = {};\n    this._headers.forEach(header => {\n      let key = header.key.toLowerCase();\n      if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n        if (!Array.isArray(addresses[key])) {\n          addresses[key] = [];\n        }\n        this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n      }\n    });\n    return addresses;\n  }\n\n  /**\n   * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n   *\n   * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n   */\n  getEnvelope() {\n    if (this._envelope) {\n      return this._envelope;\n    }\n    let envelope = {\n      from: false,\n      to: []\n    };\n    this._headers.forEach(header => {\n      let list = [];\n      if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].includes(header.key)) {\n        this._convertAddresses(this._parseAddresses(header.value), list);\n        if (list.length && list[0]) {\n          envelope.from = list[0].address;\n        }\n      } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n        this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n      }\n    });\n    envelope.to = envelope.to.map(to => to.address);\n    return envelope;\n  }\n\n  /**\n   * Returns Message-Id value. If it does not exist, then creates one\n   *\n   * @return {String} Message-Id value\n   */\n  messageId() {\n    let messageId = this.getHeader('Message-ID');\n    // You really should define your own Message-Id field!\n    if (!messageId) {\n      messageId = this._generateMessageId();\n      this.setHeader('Message-ID', messageId);\n    }\n    return messageId;\n  }\n\n  /**\n   * Sets pregenerated content that will be used as the output of this node\n   *\n   * @param {String|Buffer|Stream} Raw MIME contents\n   */\n  setRaw(raw) {\n    this._raw = raw;\n    if (this._raw && typeof this._raw.pipe === 'function') {\n      // pre-stream handler. might be triggered if a stream is set as content\n      // and 'error' fires before anything is done with this stream\n      this._contentErrorHandler = err => {\n        this._raw.removeListener('error', this._contentErrorHandler);\n        this._raw = err;\n      };\n      this._raw.once('error', this._contentErrorHandler);\n    }\n    return this;\n  }\n\n  /////// PRIVATE METHODS\n\n  /**\n   * Detects and returns handle to a stream related with the content.\n   *\n   * @param {Mixed} content Node content\n   * @returns {Object} Stream object\n   */\n  _getStream(content) {\n    let contentStream;\n    if (content._resolvedValue) {\n      // pass string or buffer content as a stream\n      contentStream = new PassThrough();\n      setImmediate(() => {\n        try {\n          contentStream.end(content._resolvedValue);\n        } catch (err) {\n          contentStream.emit('error', err);\n        }\n      });\n      return contentStream;\n    } else if (typeof content.pipe === 'function') {\n      // assume as stream\n      return content;\n    } else if (content && typeof content.path === 'string' && !content.href) {\n      if (this.disableFileAccess) {\n        contentStream = new PassThrough();\n        setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n        return contentStream;\n      }\n      // read file\n      return fs.createReadStream(content.path);\n    } else if (content && typeof content.href === 'string') {\n      if (this.disableUrlAccess) {\n        contentStream = new PassThrough();\n        setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n        return contentStream;\n      }\n      // fetch URL\n      return nmfetch(content.href, {\n        headers: content.httpHeaders\n      });\n    } else {\n      // pass string or buffer content as a stream\n      contentStream = new PassThrough();\n      setImmediate(() => {\n        try {\n          contentStream.end(content || '');\n        } catch (err) {\n          contentStream.emit('error', err);\n        }\n      });\n      return contentStream;\n    }\n  }\n\n  /**\n   * Parses addresses. Takes in a single address or an array or an\n   * array of address arrays (eg. To: [[first group], [second group],...])\n   *\n   * @param {Mixed} addresses Addresses to be parsed\n   * @return {Array} An array of address objects\n   */\n  _parseAddresses(addresses) {\n    return [].concat.apply([], [].concat(addresses).map(address => {\n      // eslint-disable-line prefer-spread\n      if (address && address.address) {\n        address.address = this._normalizeAddress(address.address);\n        address.name = address.name || '';\n        return [address];\n      }\n      return addressparser(address);\n    }));\n  }\n\n  /**\n   * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n   *\n   * @param {String} key Key to be normalized\n   * @return {String} key in Camel-Case form\n   */\n  _normalizeHeaderKey(key) {\n    key = (key || '').toString()\n    // no newlines in keys\n    .replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase()\n    // use uppercase words, except MIME\n    .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n    // special case\n    .replace(/^Content-Features$/i, 'Content-features');\n    return key;\n  }\n\n  /**\n   * Checks if the content type is multipart and defines boundary if needed.\n   * Doesn't return anything, modifies object argument instead.\n   *\n   * @param {Object} structured Parsed header value for 'Content-Type' key\n   */\n  _handleContentType(structured) {\n    this.contentType = structured.value.trim().toLowerCase();\n    this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n    if (this.multipart) {\n      this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n    } else {\n      this.boundary = false;\n    }\n  }\n\n  /**\n   * Generates a multipart boundary value\n   *\n   * @return {String} boundary value\n   */\n  _generateBoundary() {\n    return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n  }\n\n  /**\n   * Encodes a header value for use in the generated rfc2822 email.\n   *\n   * @param {String} key Header key\n   * @param {String} value Header value\n   */\n  _encodeHeaderValue(key, value) {\n    key = this._normalizeHeaderKey(key);\n    switch (key) {\n      // Structured headers\n      case 'From':\n      case 'Sender':\n      case 'To':\n      case 'Cc':\n      case 'Bcc':\n      case 'Reply-To':\n        return this._convertAddresses(this._parseAddresses(value));\n\n      // values enclosed in <>\n      case 'Message-ID':\n      case 'In-Reply-To':\n      case 'Content-Id':\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        if (value.charAt(0) !== '<') {\n          value = '<' + value;\n        }\n        if (value.charAt(value.length - 1) !== '>') {\n          value = value + '>';\n        }\n        return value;\n\n      // space separated list of values enclosed in <>\n      case 'References':\n        value = [].concat.apply([], [].concat(value || '').map(elm => {\n          // eslint-disable-line prefer-spread\n          elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n          return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n        })).map(elm => {\n          if (elm.charAt(0) !== '<') {\n            elm = '<' + elm;\n          }\n          if (elm.charAt(elm.length - 1) !== '>') {\n            elm = elm + '>';\n          }\n          return elm;\n        });\n        return value.join(' ').trim();\n      case 'Date':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return value.toUTCString().replace(/GMT/, '+0000');\n        }\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        return this._encodeWords(value);\n      case 'Content-Type':\n      case 'Content-Disposition':\n        // if it includes a filename then it is already encoded\n        return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n      default:\n        value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        // encodeWords only encodes if needed, otherwise the original string is returned\n        return this._encodeWords(value);\n    }\n  }\n\n  /**\n   * Rebuilds address object using punycode and other adjustments\n   *\n   * @param {Array} addresses An array of address objects\n   * @param {Array} [uniqueList] An array to be populated with addresses\n   * @return {String} address string\n   */\n  _convertAddresses(addresses, uniqueList) {\n    let values = [];\n    uniqueList = uniqueList || [];\n    [].concat(addresses || []).forEach(address => {\n      if (address.address) {\n        address.address = this._normalizeAddress(address.address);\n        if (!address.name) {\n          values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);\n        } else if (address.name) {\n          values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);\n        }\n        if (address.address) {\n          if (!uniqueList.filter(a => a.address === address.address).length) {\n            uniqueList.push(address);\n          }\n        }\n      } else if (address.group) {\n        let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();\n        values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);\n      }\n    });\n    return values.join(', ');\n  }\n\n  /**\n   * Normalizes an email address\n   *\n   * @param {Array} address An array of address objects\n   * @return {String} address string\n   */\n  _normalizeAddress(address) {\n    address = (address || '').toString().replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n    .trim();\n    let lastAt = address.lastIndexOf('@');\n    if (lastAt < 0) {\n      // Bare username\n      return address;\n    }\n    let user = address.substr(0, lastAt);\n    let domain = address.substr(lastAt + 1);\n\n    // Usernames are not touched and are kept as is even if these include unicode\n    // Domains are punycoded by default\n    // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n    // non-unicode domains are left as is\n\n    let encodedDomain;\n    try {\n      encodedDomain = punycode.toASCII(domain.toLowerCase());\n    } catch (err) {\n      // keep as is?\n    }\n    if (user.indexOf(' ') >= 0) {\n      if (user.charAt(0) !== '\"') {\n        user = '\"' + user;\n      }\n      if (user.substr(-1) !== '\"') {\n        user = user + '\"';\n      }\n    }\n    return `${user}@${encodedDomain}`;\n  }\n\n  /**\n   * If needed, mime encodes the name part\n   *\n   * @param {String} name Name part of an address\n   * @returns {String} Mime word encoded string if needed\n   */\n  _encodeAddressName(name) {\n    if (!/^[\\w ']*$/.test(name)) {\n      if (/^[\\x20-\\x7e]*$/.test(name)) {\n        return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n      } else {\n        return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n      }\n    }\n    return name;\n  }\n\n  /**\n   * If needed, mime encodes the name part\n   *\n   * @param {String} name Name part of an address\n   * @returns {String} Mime word encoded string if needed\n   */\n  _encodeWords(value) {\n    // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n    // by default only words that include non-ascii should be converted into encoded words\n    // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n    return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n  }\n\n  /**\n   * Detects best mime encoding for a text value\n   *\n   * @param {String} value Value to check for\n   * @return {String} either 'Q' or 'B'\n   */\n  _getTextEncoding(value) {\n    value = (value || '').toString();\n    let encoding = this.textEncoding;\n    let latinLen;\n    let nonLatinLen;\n    if (!encoding) {\n      // count latin alphabet symbols and 8-bit range symbols + control symbols\n      // if there are more latin characters, then use quoted-printable\n      // encoding, otherwise use base64\n      nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n      latinLen = (value.match(/[a-z]/gi) || []).length;\n      // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n      encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n    }\n    return encoding;\n  }\n\n  /**\n   * Generates a message id\n   *\n   * @return {String} Random Message-ID value\n   */\n  _generateMessageId() {\n    return '<' + [2, 2, 2, 6].reduce(\n    // crux to generate UUID-like random strings\n    (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'), crypto.randomBytes(4).toString('hex')) + '@' +\n    // try to use the domain of the FROM address or fallback to server hostname\n    (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() + '>';\n  }\n}\nmodule.exports = MimeNode;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}