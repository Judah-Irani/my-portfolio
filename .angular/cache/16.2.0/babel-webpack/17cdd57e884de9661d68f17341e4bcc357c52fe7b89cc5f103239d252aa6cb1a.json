{"ast":null,"code":"'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst urllib = require('url');\nconst zlib = require('zlib');\nconst PassThrough = require('stream').PassThrough;\nconst Cookies = require('./cookies');\nconst packageData = require('../../package.json');\nconst net = require('net');\nconst MAX_REDIRECTS = 5;\nmodule.exports = function (url, options) {\n  return nmfetch(url, options);\n};\nmodule.exports.Cookies = Cookies;\nfunction nmfetch(url, options) {\n  options = options || {};\n  options.fetchRes = options.fetchRes || new PassThrough();\n  options.cookies = options.cookies || new Cookies();\n  options.redirects = options.redirects || 0;\n  options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n  if (options.cookie) {\n    [].concat(options.cookie || []).forEach(cookie => {\n      options.cookies.set(cookie, url);\n    });\n    options.cookie = false;\n  }\n  let fetchRes = options.fetchRes;\n  let parsed = urllib.parse(url);\n  let method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n  let finished = false;\n  let cookies;\n  let body;\n  let handler = parsed.protocol === 'https:' ? https : http;\n  let headers = {\n    'accept-encoding': 'gzip,deflate',\n    'user-agent': 'nodemailer/' + packageData.version\n  };\n  Object.keys(options.headers || {}).forEach(key => {\n    headers[key.toLowerCase().trim()] = options.headers[key];\n  });\n  if (options.userAgent) {\n    headers['user-agent'] = options.userAgent;\n  }\n  if (parsed.auth) {\n    headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');\n  }\n  if (cookies = options.cookies.get(url)) {\n    headers.cookie = cookies;\n  }\n  if (options.body) {\n    if (options.contentType !== false) {\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n    }\n    if (typeof options.body.pipe === 'function') {\n      // it's a stream\n      headers['Transfer-Encoding'] = 'chunked';\n      body = options.body;\n      body.on('error', err => {\n        if (finished) {\n          return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n      });\n    } else {\n      if (options.body instanceof Buffer) {\n        body = options.body;\n      } else if (typeof options.body === 'object') {\n        try {\n          // encodeURIComponent can fail on invalid input (partial emoji etc.)\n          body = Buffer.from(Object.keys(options.body).map(key => {\n            let value = options.body[key].toString().trim();\n            return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n          }).join('&'));\n        } catch (E) {\n          if (finished) {\n            return;\n          }\n          finished = true;\n          E.type = 'FETCH';\n          E.sourceUrl = url;\n          fetchRes.emit('error', E);\n          return;\n        }\n      } else {\n        body = Buffer.from(options.body.toString().trim());\n      }\n      headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n      headers['Content-Length'] = body.length;\n    }\n    // if method is not provided, use POST instead of GET\n    method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n  }\n  let req;\n  let reqOptions = {\n    method,\n    host: parsed.hostname,\n    path: parsed.path,\n    port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,\n    headers,\n    rejectUnauthorized: false,\n    agent: false\n  };\n  if (options.tls) {\n    Object.keys(options.tls).forEach(key => {\n      reqOptions[key] = options.tls[key];\n    });\n  }\n  if (parsed.protocol === 'https:' && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {\n    reqOptions.servername = parsed.hostname;\n  }\n  try {\n    req = handler.request(reqOptions);\n  } catch (E) {\n    finished = true;\n    setImmediate(() => {\n      E.type = 'FETCH';\n      E.sourceUrl = url;\n      fetchRes.emit('error', E);\n    });\n    return fetchRes;\n  }\n  if (options.timeout) {\n    req.setTimeout(options.timeout, () => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      req.abort();\n      let err = new Error('Request Timeout');\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n    });\n  }\n  req.on('error', err => {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    err.type = 'FETCH';\n    err.sourceUrl = url;\n    fetchRes.emit('error', err);\n  });\n  req.on('response', res => {\n    let inflate;\n    if (finished) {\n      return;\n    }\n    switch (res.headers['content-encoding']) {\n      case 'gzip':\n      case 'deflate':\n        inflate = zlib.createUnzip();\n        break;\n    }\n    if (res.headers['set-cookie']) {\n      [].concat(res.headers['set-cookie'] || []).forEach(cookie => {\n        options.cookies.set(cookie, url);\n      });\n    }\n    if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {\n      // redirect\n      options.redirects++;\n      if (options.redirects > options.maxRedirects) {\n        finished = true;\n        let err = new Error('Maximum redirect count exceeded');\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n        return;\n      }\n      // redirect does not include POST body\n      options.method = 'GET';\n      options.body = false;\n      return nmfetch(urllib.resolve(url, res.headers.location), options);\n    }\n    fetchRes.statusCode = res.statusCode;\n    fetchRes.headers = res.headers;\n    if (res.statusCode >= 300 && !options.allowErrorResponse) {\n      finished = true;\n      let err = new Error('Invalid status code ' + res.statusCode);\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n      return;\n    }\n    res.on('error', err => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      err.type = 'FETCH';\n      err.sourceUrl = url;\n      fetchRes.emit('error', err);\n      req.abort();\n    });\n    if (inflate) {\n      res.pipe(inflate).pipe(fetchRes);\n      inflate.on('error', err => {\n        if (finished) {\n          return;\n        }\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        req.abort();\n      });\n    } else {\n      res.pipe(fetchRes);\n    }\n  });\n  setImmediate(() => {\n    if (body) {\n      try {\n        if (typeof body.pipe === 'function') {\n          return body.pipe(req);\n        } else {\n          req.write(body);\n        }\n      } catch (err) {\n        finished = true;\n        err.type = 'FETCH';\n        err.sourceUrl = url;\n        fetchRes.emit('error', err);\n        return;\n      }\n    }\n    req.end();\n  });\n  return fetchRes;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}