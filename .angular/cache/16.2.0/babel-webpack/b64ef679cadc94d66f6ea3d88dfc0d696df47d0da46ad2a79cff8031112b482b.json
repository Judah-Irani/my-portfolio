{"ast":null,"code":"'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\nconst DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n  constructor(options) {\n    super(options);\n    this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n    this.stage = 'init';\n    this.options = options || {};\n    this.secureConnection = !!this.options.secure;\n    this.alreadySecured = !!this.options.secured;\n    this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n    this.host = this.options.host || 'localhost';\n    this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;\n    if (typeof this.options.secure === 'undefined' && this.port === 465) {\n      // if secure option is not set but port is 465, then default to secure\n      this.secureConnection = true;\n    }\n    this.name = this.options.name || this._getHostname();\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'smtp-connection',\n      sid: this.id\n    });\n    this.customAuth = new Map();\n    Object.keys(this.options.customAuth || {}).forEach(key => {\n      let mapKey = (key || '').toString().trim().toUpperCase();\n      if (!mapKey) {\n        return;\n      }\n      this.customAuth.set(mapKey, this.options.customAuth[key]);\n    });\n\n    /**\n     * Expose version nr, just for the reference\n     * @type {String}\n     */\n    this.version = packageInfo.version;\n\n    /**\n     * If true, then the user is authenticated\n     * @type {Boolean}\n     */\n    this.authenticated = false;\n\n    /**\n     * If set to true, this instance is no longer active\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * Defines if the current connection is secure or not. If not,\n     * STARTTLS can be used if available\n     * @private\n     */\n    this.secure = !!this.secureConnection;\n\n    /**\n     * Store incomplete messages coming from the server\n     * @private\n     */\n    this._remainder = '';\n\n    /**\n     * Unprocessed responses from the server\n     * @type {Array}\n     */\n    this._responseQueue = [];\n    this.lastServerResponse = false;\n\n    /**\n     * The socket connecting to the server\n     * @publick\n     */\n    this._socket = false;\n\n    /**\n     * Lists supported auth mechanisms\n     * @private\n     */\n    this._supportedAuth = [];\n\n    /**\n     * Set to true, if EHLO response includes \"AUTH\".\n     * If false then authentication is not tried\n     */\n    this.allowsAuth = false;\n\n    /**\n     * Includes current envelope (from, to)\n     * @private\n     */\n    this._envelope = false;\n\n    /**\n     * Lists supported extensions\n     * @private\n     */\n    this._supportedExtensions = [];\n\n    /**\n     * Defines the maximum allowed size for a single message\n     * @private\n     */\n    this._maxAllowedSize = 0;\n\n    /**\n     * Function queue to run if a data chunk comes from the server\n     * @private\n     */\n    this._responseActions = [];\n    this._recipientQueue = [];\n\n    /**\n     * Timeout variable for waiting the greeting\n     * @private\n     */\n    this._greetingTimeout = false;\n\n    /**\n     * Timeout variable for waiting the connection to start\n     * @private\n     */\n    this._connectionTimeout = false;\n\n    /**\n     * If the socket is deemed already closed\n     * @private\n     */\n    this._destroyed = false;\n\n    /**\n     * If the socket is already being closed\n     * @private\n     */\n    this._closing = false;\n\n    /**\n     * Callbacks for socket's listeners\n     */\n    this._onSocketData = chunk => this._onData(chunk);\n    this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n    this._onSocketClose = () => this._onClose();\n    this._onSocketEnd = () => this._onEnd();\n    this._onSocketTimeout = () => this._onTimeout();\n  }\n\n  /**\n   * Creates a connection to a SMTP server and sets up connection\n   * listener\n   */\n  connect(connectCallback) {\n    if (typeof connectCallback === 'function') {\n      this.once('connect', () => {\n        this.logger.debug({\n          tnx: 'smtp'\n        }, 'SMTP handshake finished');\n        connectCallback();\n      });\n      const isDestroyedMessage = this._isDestroyedMessage('connect');\n      if (isDestroyedMessage) {\n        return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n      }\n    }\n    let opts = {\n      port: this.port,\n      host: this.host,\n      allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,\n      timeout: this.options.dnsTimeout || DNS_TIMEOUT\n    };\n    if (this.options.localAddress) {\n      opts.localAddress = this.options.localAddress;\n    }\n    let setupConnectionHandlers = () => {\n      this._connectionTimeout = setTimeout(() => {\n        this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n      }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n      this._socket.on('error', this._onSocketError);\n    };\n    if (this.options.connection) {\n      // connection is already opened\n      this._socket = this.options.connection;\n      if (this.secureConnection && !this.alreadySecured) {\n        setImmediate(() => this._upgradeConnection(err => {\n          if (err) {\n            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n            return;\n          }\n          this._onConnect();\n        }));\n      } else {\n        setImmediate(() => this._onConnect());\n      }\n      return;\n    } else if (this.options.socket) {\n      // socket object is set up but not yet connected\n      this._socket = this.options.socket;\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n        try {\n          this._socket.connect(this.port, this.host, () => {\n            this._socket.setKeepAlive(true);\n            this._onConnect();\n          });\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    } else if (this.secureConnection) {\n      // connect using tls\n      if (this.options.tls) {\n        Object.keys(this.options.tls).forEach(key => {\n          opts[key] = this.options.tls[key];\n        });\n      }\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n        try {\n          this._socket = tls.connect(opts, () => {\n            this._socket.setKeepAlive(true);\n            this._onConnect();\n          });\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    } else {\n      // connect using plaintext\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n        try {\n          this._socket = net.connect(opts, () => {\n            this._socket.setKeepAlive(true);\n            this._onConnect();\n          });\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    }\n  }\n\n  /**\n   * Sends QUIT\n   */\n  quit() {\n    this._sendCommand('QUIT');\n    this._responseActions.push(this.close);\n  }\n\n  /**\n   * Closes the connection to the server\n   */\n  close() {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n    this._responseActions = [];\n\n    // allow to run this function only once\n    if (this._closing) {\n      return;\n    }\n    this._closing = true;\n    let closeMethod = 'end';\n    if (this.stage === 'init') {\n      // Close the socket immediately when connection timed out\n      closeMethod = 'destroy';\n    }\n    this.logger.debug({\n      tnx: 'smtp'\n    }, 'Closing connection to the server using \"%s\"', closeMethod);\n    let socket = this._socket && this._socket.socket || this._socket;\n    if (socket && !socket.destroyed) {\n      try {\n        this._socket[closeMethod]();\n      } catch (E) {\n        // just ignore\n      }\n    }\n    this._destroy();\n  }\n\n  /**\n   * Authenticate user\n   */\n  login(authData, callback) {\n    const isDestroyedMessage = this._isDestroyedMessage('login');\n    if (isDestroyedMessage) {\n      return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n    }\n    this._auth = authData || {};\n    // Select SASL authentication method\n    this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n    if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n      this._authMethod = 'XOAUTH2';\n    } else if (!this._authMethod || this._authMethod === 'XOAUTH2' && !this._auth.oauth2) {\n      // use first supported\n      this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n    }\n    if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n      if (this._auth.user && this._auth.pass) {\n        this._auth.credentials = {\n          user: this._auth.user,\n          pass: this._auth.pass,\n          options: this._auth.options\n        };\n      } else {\n        return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n      }\n    }\n    if (this.customAuth.has(this._authMethod)) {\n      let handler = this.customAuth.get(this._authMethod);\n      let lastResponse;\n      let returned = false;\n      let resolve = () => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authenticated',\n          method: this._authMethod\n        }, 'User %s authenticated', JSON.stringify(this._auth.user));\n        this.authenticated = true;\n        callback(null, true);\n      };\n      let reject = err => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n      };\n      let handlerResponse = handler({\n        auth: this._auth,\n        method: this._authMethod,\n        extensions: [].concat(this._supportedExtensions),\n        authMethods: [].concat(this._supportedAuth),\n        maxAllowedSize: this._maxAllowedSize || false,\n        sendCommand: (cmd, done) => {\n          let promise;\n          if (!done) {\n            promise = new Promise((resolve, reject) => {\n              done = shared.callbackPromise(resolve, reject);\n            });\n          }\n          this._responseActions.push(str => {\n            lastResponse = str;\n            let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n            let data = {\n              command: cmd,\n              response: str\n            };\n            if (codes) {\n              data.status = Number(codes[1]) || 0;\n              if (codes[2]) {\n                data.code = codes[2];\n              }\n              data.text = str.substr(codes[0].length);\n            } else {\n              data.text = str;\n              data.status = 0; // just in case we need to perform numeric comparisons\n            }\n\n            done(null, data);\n          });\n          setImmediate(() => this._sendCommand(cmd));\n          return promise;\n        },\n        resolve,\n        reject\n      });\n      if (handlerResponse && typeof handlerResponse.catch === 'function') {\n        // a promise was returned\n        handlerResponse.then(resolve).catch(reject);\n      }\n      return;\n    }\n    switch (this._authMethod) {\n      case 'XOAUTH2':\n        this._handleXOauth2Token(false, callback);\n        return;\n      case 'LOGIN':\n        this._responseActions.push(str => {\n          this._actionAUTH_LOGIN_USER(str, callback);\n        });\n        this._sendCommand('AUTH LOGIN');\n        return;\n      case 'PLAIN':\n        this._responseActions.push(str => {\n          this._actionAUTHComplete(str, callback);\n        });\n        this._sendCommand('AUTH PLAIN ' + Buffer.from(\n        //this._auth.user+'\\u0000'+\n        '\\u0000' +\n        // skip authorization identity as it causes problems with some servers\n        this._auth.credentials.user + '\\u0000' + this._auth.credentials.pass, 'utf-8').toString('base64'),\n        // log entry without passwords\n        'AUTH PLAIN ' + Buffer.from(\n        //this._auth.user+'\\u0000'+\n        '\\u0000' +\n        // skip authorization identity as it causes problems with some servers\n        this._auth.credentials.user + '\\u0000' + '/* secret */', 'utf-8').toString('base64'));\n        return;\n      case 'CRAM-MD5':\n        this._responseActions.push(str => {\n          this._actionAUTH_CRAM_MD5(str, callback);\n        });\n        this._sendCommand('AUTH CRAM-MD5');\n        return;\n    }\n    return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n  }\n\n  /**\n   * Sends a message\n   *\n   * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n   * @param {Object} message String, Buffer or a Stream\n   * @param {Function} callback Callback to return once sending is completed\n   */\n  send(envelope, message, done) {\n    if (!message) {\n      return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n    }\n    const isDestroyedMessage = this._isDestroyedMessage('send message');\n    if (isDestroyedMessage) {\n      return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n    }\n\n    // reject larger messages than allowed\n    if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n      return setImmediate(() => {\n        done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n      });\n    }\n\n    // ensure that callback is only called once\n    let returned = false;\n    let callback = function () {\n      if (returned) {\n        return;\n      }\n      returned = true;\n      done(...arguments);\n    };\n    if (typeof message.on === 'function') {\n      message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n    }\n    let startTime = Date.now();\n    this._setEnvelope(envelope, (err, info) => {\n      if (err) {\n        return callback(err);\n      }\n      let envelopeTime = Date.now();\n      let stream = this._createSendStream((err, str) => {\n        if (err) {\n          return callback(err);\n        }\n        info.envelopeTime = envelopeTime - startTime;\n        info.messageTime = Date.now() - envelopeTime;\n        info.messageSize = stream.outByteCount;\n        info.response = str;\n        return callback(null, info);\n      });\n      if (typeof message.pipe === 'function') {\n        message.pipe(stream);\n      } else {\n        stream.write(message);\n        stream.end();\n      }\n    });\n  }\n\n  /**\n   * Resets connection state\n   *\n   * @param {Function} callback Callback to return once connection is reset\n   */\n  reset(callback) {\n    this._sendCommand('RSET');\n    this._responseActions.push(str => {\n      if (str.charAt(0) !== '2') {\n        return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n      }\n      this._envelope = false;\n      return callback(null, true);\n    });\n  }\n\n  /**\n   * Connection listener that is run when the connection to\n   * the server is opened\n   *\n   * @event\n   */\n  _onConnect() {\n    clearTimeout(this._connectionTimeout);\n    this.logger.info({\n      tnx: 'network',\n      localAddress: this._socket.localAddress,\n      localPort: this._socket.localPort,\n      remoteAddress: this._socket.remoteAddress,\n      remotePort: this._socket.remotePort\n    }, '%s established to %s:%s', this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);\n    if (this._destroyed) {\n      // Connection was established after we already had canceled it\n      this.close();\n      return;\n    }\n    this.stage = 'connected';\n\n    // clear existing listeners for the socket\n    this._socket.removeListener('data', this._onSocketData);\n    this._socket.removeListener('timeout', this._onSocketTimeout);\n    this._socket.removeListener('close', this._onSocketClose);\n    this._socket.removeListener('end', this._onSocketEnd);\n    this._socket.on('data', this._onSocketData);\n    this._socket.once('close', this._onSocketClose);\n    this._socket.once('end', this._onSocketEnd);\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n    this._socket.on('timeout', this._onSocketTimeout);\n    this._greetingTimeout = setTimeout(() => {\n      // if still waiting for greeting, give up\n      if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n        this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n      }\n    }, this.options.greetingTimeout || GREETING_TIMEOUT);\n    this._responseActions.push(this._actionGreeting);\n\n    // we have a 'data' listener set up so resume socket if it was paused\n    this._socket.resume();\n  }\n\n  /**\n   * 'data' listener for data coming from the server\n   *\n   * @event\n   * @param {Buffer} chunk Data chunk coming from the server\n   */\n  _onData(chunk) {\n    if (this._destroyed || !chunk || !chunk.length) {\n      return;\n    }\n    let data = (chunk || '').toString('binary');\n    let lines = (this._remainder + data).split(/\\r?\\n/);\n    let lastline;\n    this._remainder = lines.pop();\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (this._responseQueue.length) {\n        lastline = this._responseQueue[this._responseQueue.length - 1];\n        if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n          this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n          continue;\n        }\n      }\n      this._responseQueue.push(lines[i]);\n    }\n    if (this._responseQueue.length) {\n      lastline = this._responseQueue[this._responseQueue.length - 1];\n      if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n        return;\n      }\n    }\n    this._processResponse();\n  }\n\n  /**\n   * 'error' listener for the socket\n   *\n   * @event\n   * @param {Error} err Error object\n   * @param {String} type Error name\n   */\n  _onError(err, type, data, command) {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n    if (this._destroyed) {\n      // just ignore, already closed\n      // this might happen when a socket is canceled because of reached timeout\n      // but the socket timeout error itself receives only after\n      return;\n    }\n    err = this._formatError(err, type, data, command);\n    this.logger.error(data, err.message);\n    this.emit('error', err);\n    this.close();\n  }\n  _formatError(message, type, response, command) {\n    let err;\n    if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n      err = message;\n    } else {\n      err = new Error(message);\n    }\n    if (type && type !== 'Error') {\n      err.code = type;\n    }\n    if (response) {\n      err.response = response;\n      err.message += ': ' + response;\n    }\n    let responseCode = typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0]) || false;\n    if (responseCode) {\n      err.responseCode = responseCode;\n    }\n    if (command) {\n      err.command = command;\n    }\n    return err;\n  }\n\n  /**\n   * 'close' listener for the socket\n   *\n   * @event\n   */\n  _onClose() {\n    let serverResponse = false;\n    if (this._remainder && this._remainder.trim()) {\n      if (this.options.debug || this.options.transactionLog) {\n        this.logger.debug({\n          tnx: 'server'\n        }, this._remainder.replace(/\\r?\\n$/, ''));\n      }\n      this.lastServerResponse = serverResponse = this._remainder.trim();\n    }\n    this.logger.info({\n      tnx: 'network'\n    }, 'Connection closed');\n    if (this.upgrading && !this._destroyed) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', serverResponse, 'CONN');\n    } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');\n    } else if (/^[45]\\d{2}\\b/.test(serverResponse)) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');\n    }\n    this._destroy();\n  }\n\n  /**\n   * 'end' listener for the socket\n   *\n   * @event\n   */\n  _onEnd() {\n    if (this._socket && !this._socket.destroyed) {\n      this._socket.destroy();\n    }\n  }\n\n  /**\n   * 'timeout' listener for the socket\n   *\n   * @event\n   */\n  _onTimeout() {\n    return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n  }\n\n  /**\n   * Destroys the client, emits 'end'\n   */\n  _destroy() {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    this.emit('end');\n  }\n\n  /**\n   * Upgrades the connection to TLS\n   *\n   * @param {Function} callback Callback function to run when the connection\n   *        has been secured\n   */\n  _upgradeConnection(callback) {\n    // do not remove all listeners or it breaks node v0.10 as there's\n    // apparently a 'finish' event set that would be cleared as well\n\n    // we can safely keep 'error', 'end', 'close' etc. events\n    this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n    this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n    let socketPlain = this._socket;\n    let opts = {\n      socket: this._socket,\n      host: this.host\n    };\n    Object.keys(this.options.tls || {}).forEach(key => {\n      opts[key] = this.options.tls[key];\n    });\n    this.upgrading = true;\n    // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch\n    try {\n      this._socket = tls.connect(opts, () => {\n        this.secure = true;\n        this.upgrading = false;\n        this._socket.on('data', this._onSocketData);\n        socketPlain.removeListener('close', this._onSocketClose);\n        socketPlain.removeListener('end', this._onSocketEnd);\n        return callback(null, true);\n      });\n    } catch (err) {\n      return callback(err);\n    }\n    this._socket.on('error', this._onSocketError);\n    this._socket.once('close', this._onSocketClose);\n    this._socket.once('end', this._onSocketEnd);\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n    this._socket.on('timeout', this._onSocketTimeout);\n\n    // resume in case the socket was paused\n    socketPlain.resume();\n  }\n\n  /**\n   * Processes queued responses from the server\n   *\n   * @param {Boolean} force If true, ignores _processing flag\n   */\n  _processResponse() {\n    if (!this._responseQueue.length) {\n      return false;\n    }\n    let str = this.lastServerResponse = (this._responseQueue.shift() || '').toString();\n    if (/^\\d+-/.test(str.split('\\n').pop())) {\n      // keep waiting for the final part of multiline response\n      return;\n    }\n    if (this.options.debug || this.options.transactionLog) {\n      this.logger.debug({\n        tnx: 'server'\n      }, str.replace(/\\r?\\n$/, ''));\n    }\n    if (!str.trim()) {\n      // skip unexpected empty lines\n      setImmediate(() => this._processResponse());\n    }\n    let action = this._responseActions.shift();\n    if (typeof action === 'function') {\n      action.call(this, str);\n      setImmediate(() => this._processResponse());\n    } else {\n      return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n    }\n  }\n\n  /**\n   * Send a command to the server, append \\r\\n\n   *\n   * @param {String} str String to be sent to the server\n   * @param {String} logStr Optional string to be used for logging instead of the actual string\n   */\n  _sendCommand(str, logStr) {\n    if (this._destroyed) {\n      // Connection already closed, can't send any more data\n      return;\n    }\n    if (this._socket.destroyed) {\n      return this.close();\n    }\n    if (this.options.debug || this.options.transactionLog) {\n      this.logger.debug({\n        tnx: 'client'\n      }, (logStr || str || '').toString().replace(/\\r?\\n$/, ''));\n    }\n    this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n  }\n\n  /**\n   * Initiates a new message by submitting envelope data, starting with\n   * MAIL FROM: command\n   *\n   * @param {Object} envelope Envelope object in the form of\n   *        {from:'...', to:['...']}\n   *        or\n   *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n   */\n  _setEnvelope(envelope, callback) {\n    let args = [];\n    let useSmtpUtf8 = false;\n    this._envelope = envelope || {};\n    this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();\n    this._envelope.to = [].concat(this._envelope.to || []).map(to => (to && to.address || to || '').toString().trim());\n    if (!this._envelope.to.length) {\n      return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n    }\n    if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n      return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n    }\n\n    // check if the sender address uses only ASCII characters,\n    // otherwise require usage of SMTPUTF8 extension\n    if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n      useSmtpUtf8 = true;\n    }\n    for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n      if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n        return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n      }\n\n      // check if the recipients addresses use only ASCII characters,\n      // otherwise require usage of SMTPUTF8 extension\n      if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n        useSmtpUtf8 = true;\n      }\n    }\n\n    // clone the recipients array for latter manipulation\n    this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n    this._envelope.rejected = [];\n    this._envelope.rejectedErrors = [];\n    this._envelope.accepted = [];\n    if (this._envelope.dsn) {\n      try {\n        this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n      } catch (err) {\n        return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n      }\n    }\n    this._responseActions.push(str => {\n      this._actionMAIL(str, callback);\n    });\n\n    // If the server supports SMTPUTF8 and the envelope includes an internationalized\n    // email address then append SMTPUTF8 keyword to the MAIL FROM command\n    if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n      args.push('SMTPUTF8');\n      this._usingSmtpUtf8 = true;\n    }\n\n    // If the server supports 8BITMIME and the message might contain non-ascii bytes\n    // then append the 8BITMIME keyword to the MAIL FROM command\n    if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n      args.push('BODY=8BITMIME');\n      this._using8BitMime = true;\n    }\n    if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n      args.push('SIZE=' + this._envelope.size);\n    }\n\n    // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the MAIL FROM command\n    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n      if (this._envelope.dsn.ret) {\n        args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n      }\n      if (this._envelope.dsn.envid) {\n        args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n      }\n    }\n    this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n  }\n  _setDsnEnvelope(params) {\n    let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n    if (ret) {\n      switch (ret) {\n        case 'HDRS':\n        case 'HEADERS':\n          ret = 'HDRS';\n          break;\n        case 'FULL':\n        case 'BODY':\n          ret = 'FULL';\n          break;\n      }\n    }\n    if (ret && !['FULL', 'HDRS'].includes(ret)) {\n      throw new Error('ret: ' + JSON.stringify(ret));\n    }\n    let envid = (params.envid || params.id || '').toString() || null;\n    let notify = params.notify || null;\n    if (notify) {\n      if (typeof notify === 'string') {\n        notify = notify.split(',');\n      }\n      notify = notify.map(n => n.trim().toUpperCase());\n      let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n      let invaliNotify = notify.filter(n => !validNotify.includes(n));\n      if (invaliNotify.length || notify.length > 1 && notify.includes('NEVER')) {\n        throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n      }\n      notify = notify.join(',');\n    }\n    let orcpt = (params.recipient || params.orcpt || '').toString() || null;\n    if (orcpt && orcpt.indexOf(';') < 0) {\n      orcpt = 'rfc822;' + orcpt;\n    }\n    return {\n      ret,\n      envid,\n      notify,\n      orcpt\n    };\n  }\n  _getDsnRcptToArgs() {\n    let args = [];\n    // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the RCPT TO command\n    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n      if (this._envelope.dsn.notify) {\n        args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n      }\n      if (this._envelope.dsn.orcpt) {\n        args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n      }\n    }\n    return args.length ? ' ' + args.join(' ') : '';\n  }\n  _createSendStream(callback) {\n    let dataStream = new DataStream();\n    let logStream;\n    if (this.options.lmtp) {\n      this._envelope.accepted.forEach((recipient, i) => {\n        let final = i === this._envelope.accepted.length - 1;\n        this._responseActions.push(str => {\n          this._actionLMTPStream(recipient, final, str, callback);\n        });\n      });\n    } else {\n      this._responseActions.push(str => {\n        this._actionSMTPStream(str, callback);\n      });\n    }\n    dataStream.pipe(this._socket, {\n      end: false\n    });\n    if (this.options.debug) {\n      logStream = new PassThrough();\n      logStream.on('readable', () => {\n        let chunk;\n        while (chunk = logStream.read()) {\n          this.logger.debug({\n            tnx: 'message'\n          }, chunk.toString('binary').replace(/\\r?\\n$/, ''));\n        }\n      });\n      dataStream.pipe(logStream);\n    }\n    dataStream.once('end', () => {\n      this.logger.info({\n        tnx: 'message',\n        inByteCount: dataStream.inByteCount,\n        outByteCount: dataStream.outByteCount\n      }, '<%s bytes encoded mime message (source size %s bytes)>', dataStream.outByteCount, dataStream.inByteCount);\n    });\n    return dataStream;\n  }\n\n  /** ACTIONS **/\n\n  /**\n   * Will be run after the connection is created and the server sends\n   * a greeting. If the incoming message starts with 220 initiate\n   * SMTP session by sending EHLO command\n   *\n   * @param {String} str Message from the server\n   */\n  _actionGreeting(str) {\n    clearTimeout(this._greetingTimeout);\n    if (str.substr(0, 3) !== '220') {\n      this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n      return;\n    }\n    if (this.options.lmtp) {\n      this._responseActions.push(this._actionLHLO);\n      this._sendCommand('LHLO ' + this.name);\n    } else {\n      this._responseActions.push(this._actionEHLO);\n      this._sendCommand('EHLO ' + this.name);\n    }\n  }\n\n  /**\n   * Handles server response for LHLO command. If it yielded in\n   * error, emit 'error', otherwise treat this as an EHLO response\n   *\n   * @param {String} str Message from the server\n   */\n  _actionLHLO(str) {\n    if (str.charAt(0) !== '2') {\n      this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n      return;\n    }\n    this._actionEHLO(str);\n  }\n\n  /**\n   * Handles server response for EHLO command. If it yielded in\n   * error, try HELO instead, otherwise initiate TLS negotiation\n   * if STARTTLS is supported by the server or move into the\n   * authentication phase.\n   *\n   * @param {String} str Message from the server\n   */\n  _actionEHLO(str) {\n    let match;\n    if (str.substr(0, 3) === '421') {\n      this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n      return;\n    }\n    if (str.charAt(0) !== '2') {\n      if (this.options.requireTLS) {\n        this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n        return;\n      }\n\n      // Try HELO instead\n      this._responseActions.push(this._actionHELO);\n      this._sendCommand('HELO ' + this.name);\n      return;\n    }\n    this._ehloLines = str.split(/\\r?\\n/).map(line => line.replace(/^\\d+[ -]/, '').trim()).filter(line => line).slice(1);\n\n    // Detect if the server supports STARTTLS\n    if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n      this._sendCommand('STARTTLS');\n      this._responseActions.push(this._actionSTARTTLS);\n      return;\n    }\n\n    // Detect if the server supports SMTPUTF8\n    if (/[ -]SMTPUTF8\\b/im.test(str)) {\n      this._supportedExtensions.push('SMTPUTF8');\n    }\n\n    // Detect if the server supports DSN\n    if (/[ -]DSN\\b/im.test(str)) {\n      this._supportedExtensions.push('DSN');\n    }\n\n    // Detect if the server supports 8BITMIME\n    if (/[ -]8BITMIME\\b/im.test(str)) {\n      this._supportedExtensions.push('8BITMIME');\n    }\n\n    // Detect if the server supports PIPELINING\n    if (/[ -]PIPELINING\\b/im.test(str)) {\n      this._supportedExtensions.push('PIPELINING');\n    }\n\n    // Detect if the server supports AUTH\n    if (/[ -]AUTH\\b/i.test(str)) {\n      this.allowsAuth = true;\n    }\n\n    // Detect if the server supports PLAIN auth\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n      this._supportedAuth.push('PLAIN');\n    }\n\n    // Detect if the server supports LOGIN auth\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n      this._supportedAuth.push('LOGIN');\n    }\n\n    // Detect if the server supports CRAM-MD5 auth\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n      this._supportedAuth.push('CRAM-MD5');\n    }\n\n    // Detect if the server supports XOAUTH2 auth\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n      this._supportedAuth.push('XOAUTH2');\n    }\n\n    // Detect if the server supports SIZE extensions (and the max allowed size)\n    if (match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im)) {\n      this._supportedExtensions.push('SIZE');\n      this._maxAllowedSize = Number(match[1]) || 0;\n    }\n    this.emit('connect');\n  }\n\n  /**\n   * Handles server response for HELO command. If it yielded in\n   * error, emit 'error', otherwise move into the authentication phase.\n   *\n   * @param {String} str Message from the server\n   */\n  _actionHELO(str) {\n    if (str.charAt(0) !== '2') {\n      this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n      return;\n    }\n\n    // assume that authentication is enabled (most probably is not though)\n    this.allowsAuth = true;\n    this.emit('connect');\n  }\n\n  /**\n   * Handles server response for STARTTLS command. If there's an error\n   * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n   * succeedes restart the EHLO\n   *\n   * @param {String} str Message from the server\n   */\n  _actionSTARTTLS(str) {\n    if (str.charAt(0) !== '2') {\n      if (this.options.opportunisticTLS) {\n        this.logger.info({\n          tnx: 'smtp'\n        }, 'Failed STARTTLS upgrade, continuing unencrypted');\n        return this.emit('connect');\n      }\n      this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n      return;\n    }\n    this._upgradeConnection((err, secured) => {\n      if (err) {\n        this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n        return;\n      }\n      this.logger.info({\n        tnx: 'smtp'\n      }, 'Connection upgraded with STARTTLS');\n      if (secured) {\n        // restart session\n        if (this.options.lmtp) {\n          this._responseActions.push(this._actionLHLO);\n          this._sendCommand('LHLO ' + this.name);\n        } else {\n          this._responseActions.push(this._actionEHLO);\n          this._sendCommand('EHLO ' + this.name);\n        }\n      } else {\n        this.emit('connect');\n      }\n    });\n  }\n\n  /**\n   * Handle the response for AUTH LOGIN command. We are expecting\n   * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n   * response needs to be base64 encoded username. We do not need\n   * exact match but settle with 334 response in general as some\n   * hosts invalidly use a longer message than VXNlcm5hbWU6\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTH_LOGIN_USER(str, callback) {\n    if (!/^334[ -]/.test(str)) {\n      // expecting '334 VXNlcm5hbWU6'\n      callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n      return;\n    }\n    this._responseActions.push(str => {\n      this._actionAUTH_LOGIN_PASS(str, callback);\n    });\n    this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n  }\n\n  /**\n   * Handle the response for AUTH CRAM-MD5 command. We are expecting\n   * '334 <challenge string>'. Data to be sent as response needs to be\n   * base64 decoded challenge string, MD5 hashed using the password as\n   * a HMAC key, prefixed by the username and a space, and finally all\n   * base64 encoded again.\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTH_CRAM_MD5(str, callback) {\n    let challengeMatch = str.match(/^334\\s+(.+)$/);\n    let challengeString = '';\n    if (!challengeMatch) {\n      return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    } else {\n      challengeString = challengeMatch[1];\n    }\n\n    // Decode from base64\n    let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n      hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);\n    hmacMD5.update(base64decoded);\n    let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');\n    this._responseActions.push(str => {\n      this._actionAUTH_CRAM_MD5_PASS(str, callback);\n    });\n    this._sendCommand(Buffer.from(prepended).toString('base64'),\n    // hidden hash for logs\n    Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64'));\n  }\n\n  /**\n   * Handles the response to CRAM-MD5 authentication, if there's no error,\n   * the user can be considered logged in. Start waiting for a message to send\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTH_CRAM_MD5_PASS(str, callback) {\n    if (!str.match(/^235\\s+/)) {\n      return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    }\n    this.logger.info({\n      tnx: 'smtp',\n      username: this._auth.user,\n      action: 'authenticated',\n      method: this._authMethod\n    }, 'User %s authenticated', JSON.stringify(this._auth.user));\n    this.authenticated = true;\n    callback(null, true);\n  }\n\n  /**\n   * Handle the response for AUTH LOGIN command. We are expecting\n   * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n   * response needs to be base64 encoded password.\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTH_LOGIN_PASS(str, callback) {\n    if (!/^334[ -]/.test(str)) {\n      // expecting '334 UGFzc3dvcmQ6'\n      return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n    }\n    this._responseActions.push(str => {\n      this._actionAUTHComplete(str, callback);\n    });\n    this._sendCommand(Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),\n    // Hidden pass for logs\n    Buffer.from('/* secret */', 'utf-8').toString('base64'));\n  }\n\n  /**\n   * Handles the response for authentication, if there's no error,\n   * the user can be considered logged in. Start waiting for a message to send\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTHComplete(str, isRetry, callback) {\n    if (!callback && typeof isRetry === 'function') {\n      callback = isRetry;\n      isRetry = false;\n    }\n    if (str.substr(0, 3) === '334') {\n      this._responseActions.push(str => {\n        if (isRetry || this._authMethod !== 'XOAUTH2') {\n          this._actionAUTHComplete(str, true, callback);\n        } else {\n          // fetch a new OAuth2 access token\n          setImmediate(() => this._handleXOauth2Token(true, callback));\n        }\n      });\n      this._sendCommand('');\n      return;\n    }\n    if (str.charAt(0) !== '2') {\n      this.logger.info({\n        tnx: 'smtp',\n        username: this._auth.user,\n        action: 'authfail',\n        method: this._authMethod\n      }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n      return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n    }\n    this.logger.info({\n      tnx: 'smtp',\n      username: this._auth.user,\n      action: 'authenticated',\n      method: this._authMethod\n    }, 'User %s authenticated', JSON.stringify(this._auth.user));\n    this.authenticated = true;\n    callback(null, true);\n  }\n\n  /**\n   * Handle response for a MAIL FROM: command\n   *\n   * @param {String} str Message from the server\n   */\n  _actionMAIL(str, callback) {\n    let message, curRecipient;\n    if (Number(str.charAt(0)) !== 2) {\n      if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n        message = 'Internationalized mailbox name not allowed';\n      } else {\n        message = 'Mail command failed';\n      }\n      return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n    }\n    if (!this._envelope.rcptQueue.length) {\n      return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n    } else {\n      this._recipientQueue = [];\n      if (this._supportedExtensions.includes('PIPELINING')) {\n        while (this._envelope.rcptQueue.length) {\n          curRecipient = this._envelope.rcptQueue.shift();\n          this._recipientQueue.push(curRecipient);\n          this._responseActions.push(str => {\n            this._actionRCPT(str, callback);\n          });\n          this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n      } else {\n        curRecipient = this._envelope.rcptQueue.shift();\n        this._recipientQueue.push(curRecipient);\n        this._responseActions.push(str => {\n          this._actionRCPT(str, callback);\n        });\n        this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n      }\n    }\n  }\n\n  /**\n   * Handle response for a RCPT TO: command\n   *\n   * @param {String} str Message from the server\n   */\n  _actionRCPT(str, callback) {\n    let message,\n      err,\n      curRecipient = this._recipientQueue.shift();\n    if (Number(str.charAt(0)) !== 2) {\n      // this is a soft error\n      if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n        message = 'Internationalized mailbox name not allowed';\n      } else {\n        message = 'Recipient command failed';\n      }\n      this._envelope.rejected.push(curRecipient);\n      // store error for the failed recipient\n      err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n      err.recipient = curRecipient;\n      this._envelope.rejectedErrors.push(err);\n    } else {\n      this._envelope.accepted.push(curRecipient);\n    }\n    if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n      if (this._envelope.rejected.length < this._envelope.to.length) {\n        this._responseActions.push(str => {\n          this._actionDATA(str, callback);\n        });\n        this._sendCommand('DATA');\n      } else {\n        err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n        err.rejected = this._envelope.rejected;\n        err.rejectedErrors = this._envelope.rejectedErrors;\n        return callback(err);\n      }\n    } else if (this._envelope.rcptQueue.length) {\n      curRecipient = this._envelope.rcptQueue.shift();\n      this._recipientQueue.push(curRecipient);\n      this._responseActions.push(str => {\n        this._actionRCPT(str, callback);\n      });\n      this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n    }\n  }\n\n  /**\n   * Handle response for a DATA command\n   *\n   * @param {String} str Message from the server\n   */\n  _actionDATA(str, callback) {\n    // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n    // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n    if (!/^[23]/.test(str)) {\n      return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n    }\n    let response = {\n      accepted: this._envelope.accepted,\n      rejected: this._envelope.rejected\n    };\n    if (this._ehloLines && this._ehloLines.length) {\n      response.ehlo = this._ehloLines;\n    }\n    if (this._envelope.rejectedErrors.length) {\n      response.rejectedErrors = this._envelope.rejectedErrors;\n    }\n    callback(null, response);\n  }\n\n  /**\n   * Handle response for a DATA stream when using SMTP\n   * We expect a single response that defines if the sending succeeded or failed\n   *\n   * @param {String} str Message from the server\n   */\n  _actionSMTPStream(str, callback) {\n    if (Number(str.charAt(0)) !== 2) {\n      // Message failed\n      return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n    } else {\n      // Message sent succesfully\n      return callback(null, str);\n    }\n  }\n\n  /**\n   * Handle response for a DATA stream\n   * We expect a separate response for every recipient. All recipients can either\n   * succeed or fail separately\n   *\n   * @param {String} recipient The recipient this response applies to\n   * @param {Boolean} final Is this the final recipient?\n   * @param {String} str Message from the server\n   */\n  _actionLMTPStream(recipient, final, str, callback) {\n    let err;\n    if (Number(str.charAt(0)) !== 2) {\n      // Message failed\n      err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n      err.recipient = recipient;\n      this._envelope.rejected.push(recipient);\n      this._envelope.rejectedErrors.push(err);\n      for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n        if (this._envelope.accepted[i] === recipient) {\n          this._envelope.accepted.splice(i, 1);\n        }\n      }\n    }\n    if (final) {\n      return callback(null, str);\n    }\n  }\n  _handleXOauth2Token(isRetry, callback) {\n    this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n      if (err) {\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authfail',\n          method: this._authMethod\n        }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n        return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n      }\n      this._responseActions.push(str => {\n        this._actionAUTHComplete(str, isRetry, callback);\n      });\n      this._sendCommand('AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken),\n      //  Hidden for logs\n      'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */'));\n    });\n  }\n\n  /**\n   *\n   * @param {string} command\n   * @private\n   */\n  _isDestroyedMessage(command) {\n    if (this._destroyed) {\n      return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n    }\n    if (this._socket) {\n      if (this._socket.destroyed) {\n        return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n      }\n      if (!this._socket.writable) {\n        return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n      }\n    }\n  }\n  _getHostname() {\n    // defaul hostname is machine hostname or [IP]\n    let defaultHostname;\n    try {\n      defaultHostname = os.hostname() || '';\n    } catch (err) {\n      // fails on windows 7\n      defaultHostname = 'localhost';\n    }\n\n    // ignore if not FQDN\n    if (!defaultHostname || defaultHostname.indexOf('.') < 0) {\n      defaultHostname = '[127.0.0.1]';\n    }\n\n    // IP should be enclosed in []\n    if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n      defaultHostname = '[' + defaultHostname + ']';\n    }\n    return defaultHostname;\n  }\n}\nmodule.exports = SMTPConnection;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}