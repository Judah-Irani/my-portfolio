{"ast":null,"code":"import { InjectionToken, Injectable, NgZone, Optional, Inject, Pipe, NgModule } from '@angular/core';\nimport { ApolloClient } from 'apollo-client';\nimport { Observable, queueScheduler, observable, from } from 'rxjs';\nimport { observeOn, startWith } from 'rxjs/operators';\nfunction fromPromise(promiseFn) {\n  return new Observable(subscriber => {\n    promiseFn().then(result => {\n      if (!subscriber.closed) {\n        subscriber.next(result);\n        subscriber.complete();\n      }\n    }, error => {\n      if (!subscriber.closed) {\n        subscriber.error(error);\n      }\n    });\n    return () => subscriber.unsubscribe();\n  });\n}\nclass ZoneScheduler {\n  constructor(zone) {\n    this.zone = zone;\n    this.now = Date.now ? Date.now : () => +new Date();\n  }\n  schedule(work, delay = 0, state) {\n    return this.zone.run(() => queueScheduler.schedule(work, delay, state));\n  }\n}\n// XXX: Apollo's QueryObservable is not compatible with RxJS\n// TODO: remove it in one of future releases\n// https://github.com/ReactiveX/rxjs/blob/9fb0ce9e09c865920cf37915cc675e3b3a75050b/src/internal/util/subscribeTo.ts#L32\nfunction fixObservable(obs) {\n  obs[observable] = () => obs;\n  return obs;\n}\nfunction wrapWithZone(obs, ngZone) {\n  return obs.pipe(observeOn(new ZoneScheduler(ngZone)));\n}\nclass QueryRef {\n  constructor(obsQuery, ngZone, options) {\n    this.obsQuery = obsQuery;\n    const wrapped = wrapWithZone(from(fixObservable(this.obsQuery)), ngZone);\n    this.valueChanges = options.useInitialLoading ? wrapped.pipe(startWith(Object.assign(Object.assign({}, this.obsQuery.getCurrentResult()), {\n      error: undefined,\n      partial: undefined,\n      stale: true\n    }))) : wrapped;\n    this.queryId = this.obsQuery.queryId;\n  }\n  // ObservableQuery's methods\n  result() {\n    return this.obsQuery.result();\n  }\n  currentResult() {\n    return this.obsQuery.currentResult();\n  }\n  getLastResult() {\n    return this.obsQuery.getLastResult();\n  }\n  getLastError() {\n    return this.obsQuery.getLastError();\n  }\n  resetLastResults() {\n    return this.obsQuery.resetLastResults();\n  }\n  refetch(variables) {\n    return this.obsQuery.refetch(variables);\n  }\n  fetchMore(fetchMoreOptions) {\n    return this.obsQuery.fetchMore(fetchMoreOptions);\n  }\n  subscribeToMore(options) {\n    // XXX: there's a bug in apollo-client typings\n    // it should not inherit types from ObservableQuery\n    return this.obsQuery.subscribeToMore(options);\n  }\n  updateQuery(mapFn) {\n    return this.obsQuery.updateQuery(mapFn);\n  }\n  stopPolling() {\n    return this.obsQuery.stopPolling();\n  }\n  startPolling(pollInterval) {\n    return this.obsQuery.startPolling(pollInterval);\n  }\n  setOptions(opts) {\n    return this.obsQuery.setOptions(opts);\n  }\n  setVariables(variables, tryFetch = false, fetchResults = true) {\n    return this.obsQuery.setVariables(variables, tryFetch, fetchResults);\n  }\n}\nconst APOLLO_OPTIONS = new InjectionToken('[apollo-angular] options');\nconst APOLLO_NAMED_OPTIONS = new InjectionToken('[apollo-angular] named options');\nclass ApolloBase {\n  constructor(ngZone, _client) {\n    this.ngZone = ngZone;\n    this._client = _client;\n  }\n  watchQuery(options) {\n    return new QueryRef(this.ensureClient().watchQuery(Object.assign({}, options)), this.ngZone, options);\n  }\n  query(options) {\n    return fromPromise(() => this.ensureClient().query(Object.assign({}, options)));\n  }\n  mutate(options) {\n    return fromPromise(() => this.ensureClient().mutate(Object.assign({}, options)));\n  }\n  subscribe(options, extra) {\n    const obs = from(fixObservable(this.ensureClient().subscribe(Object.assign({}, options))));\n    return extra && extra.useZone !== true ? obs : wrapWithZone(obs, this.ngZone);\n  }\n  /**\n   * Get an access to an instance of ApolloClient\n   */\n  getClient() {\n    return this._client;\n  }\n  /**\n   * Set a new instance of ApolloClient\n   * Remember to clean up the store before setting a new client.\n   *\n   * @param client ApolloClient instance\n   */\n  setClient(client) {\n    if (this._client) {\n      throw new Error('Client has been already defined');\n    }\n    this._client = client;\n  }\n  ensureClient() {\n    this.checkInstance();\n    return this._client;\n  }\n  checkInstance() {\n    if (!this._client) {\n      throw new Error('Client has not been defined yet');\n    }\n  }\n}\nclass Apollo extends ApolloBase {\n  constructor(_ngZone, apolloOptions, apolloNamedOptions) {\n    super(_ngZone);\n    this._ngZone = _ngZone;\n    this.map = new Map();\n    if (apolloOptions) {\n      this.createDefault(apolloOptions);\n    }\n    if (apolloNamedOptions && typeof apolloNamedOptions === 'object') {\n      for (const name in apolloNamedOptions) {\n        if (apolloNamedOptions.hasOwnProperty(name)) {\n          const options = apolloNamedOptions[name];\n          this.createNamed(name, options);\n        }\n      }\n    }\n  }\n  /**\n   * Create an instance of ApolloClient\n   * @param options Options required to create ApolloClient\n   * @param name client's name\n   */\n  create(options, name) {\n    if (isDefault(name)) {\n      this.createDefault(options);\n    } else {\n      this.createNamed(name, options);\n    }\n  }\n  /**\n   * Use a default ApolloClient\n   */\n  default() {\n    return this;\n  }\n  /**\n   * Use a named ApolloClient\n   * @param name client's name\n   */\n  use(name) {\n    if (isDefault(name)) {\n      return this.default();\n    }\n    return this.map.get(name);\n  }\n  /**\n   * Create a default ApolloClient, same as `apollo.create(options)`\n   * @param options ApolloClient's options\n   */\n  createDefault(options) {\n    if (this.getClient()) {\n      throw new Error('Apollo has been already created.');\n    }\n    return this.setClient(new ApolloClient(options));\n  }\n  /**\n   * Create a named ApolloClient, same as `apollo.create(options, name)`\n   * @param name client's name\n   * @param options ApolloClient's options\n   */\n  createNamed(name, options) {\n    if (this.map.has(name)) {\n      throw new Error(`Client ${name} has been already created`);\n    }\n    this.map.set(name, new ApolloBase(this._ngZone, new ApolloClient(options)));\n  }\n  /**\n   * Remember to clean up the store before removing a client\n   * @param name client's name\n   */\n  removeClient(name) {\n    if (isDefault(name)) {\n      this._client = undefined;\n    } else {\n      this.map.delete(name);\n    }\n  }\n}\nfunction isDefault(name) {\n  return !name || name === 'default';\n}\nclass Query {\n  constructor(apollo) {\n    this.apollo = apollo;\n    this.client = 'default';\n  }\n  watch(variables, options) {\n    return this.apollo.use(this.client).watchQuery(Object.assign(Object.assign({}, options), {\n      variables,\n      query: this.document\n    }));\n  }\n  fetch(variables, options) {\n    return this.apollo.use(this.client).query(Object.assign(Object.assign({}, options), {\n      variables,\n      query: this.document\n    }));\n  }\n}\nclass Mutation {\n  constructor(apollo) {\n    this.apollo = apollo;\n    this.client = 'default';\n  }\n  mutate(variables, options) {\n    return this.apollo.use(this.client).mutate(Object.assign(Object.assign({}, options), {\n      variables,\n      mutation: this.document\n    }));\n  }\n}\nclass Subscription {\n  constructor(apollo) {\n    this.apollo = apollo;\n    this.client = 'default';\n  }\n  subscribe(variables, options, extra) {\n    return this.apollo.use(this.client).subscribe(Object.assign(Object.assign({}, options), {\n      variables,\n      query: this.document\n    }), extra);\n  }\n}\nclass SelectPipe {\n  transform(obj, name = '') {\n    if (name !== '') {\n      return obj && obj.data && obj.data[name];\n    }\n  }\n}\nconst PROVIDERS = [Apollo];\nconst DECLARATIONS = [SelectPipe];\nclass ApolloModule {}\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { APOLLO_NAMED_OPTIONS, APOLLO_OPTIONS, Apollo, ApolloBase, ApolloModule, Mutation, Query, QueryRef, SelectPipe, Subscription, PROVIDERS as ɵa, DECLARATIONS as ɵb };\n//# sourceMappingURL=ngApollo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}