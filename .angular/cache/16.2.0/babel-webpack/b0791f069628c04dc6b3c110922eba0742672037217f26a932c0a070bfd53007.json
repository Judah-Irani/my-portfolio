{"ast":null,"code":"'use strict';\n\nconst SMTPConnection = require('../smtp-connection');\nconst assign = require('../shared').assign;\nconst XOAuth2 = require('../xoauth2');\nconst EventEmitter = require('events');\n\n/**\n * Creates an element for the pool\n *\n * @constructor\n * @param {Object} options SMTPPool instance\n */\nclass PoolResource extends EventEmitter {\n  constructor(pool) {\n    super();\n    this.pool = pool;\n    this.options = pool.options;\n    this.logger = this.pool.logger;\n    if (this.options.auth) {\n      switch ((this.options.auth.type || '').toString().toUpperCase()) {\n        case 'OAUTH2':\n          {\n            let oauth2 = new XOAuth2(this.options.auth, this.logger);\n            oauth2.provisionCallback = this.pool.mailer && this.pool.mailer.get('oauth2_provision_cb') || oauth2.provisionCallback;\n            this.auth = {\n              type: 'OAUTH2',\n              user: this.options.auth.user,\n              oauth2,\n              method: 'XOAUTH2'\n            };\n            oauth2.on('token', token => this.pool.mailer.emit('token', token));\n            oauth2.on('error', err => this.emit('error', err));\n            break;\n          }\n        default:\n          if (!this.options.auth.user && !this.options.auth.pass) {\n            break;\n          }\n          this.auth = {\n            type: (this.options.auth.type || '').toString().toUpperCase() || 'LOGIN',\n            user: this.options.auth.user,\n            credentials: {\n              user: this.options.auth.user || '',\n              pass: this.options.auth.pass,\n              options: this.options.auth.options\n            },\n            method: (this.options.auth.method || '').trim().toUpperCase() || this.options.authMethod || false\n          };\n      }\n    }\n    this._connection = false;\n    this._connected = false;\n    this.messages = 0;\n    this.available = true;\n  }\n\n  /**\n   * Initiates a connection to the SMTP server\n   *\n   * @param {Function} callback Callback function to run once the connection is established or failed\n   */\n  connect(callback) {\n    this.pool.getSocket(this.options, (err, socketOptions) => {\n      if (err) {\n        return callback(err);\n      }\n      let returned = false;\n      let options = this.options;\n      if (socketOptions && socketOptions.connection) {\n        this.logger.info({\n          tnx: 'proxy',\n          remoteAddress: socketOptions.connection.remoteAddress,\n          remotePort: socketOptions.connection.remotePort,\n          destHost: options.host || '',\n          destPort: options.port || '',\n          action: 'connected'\n        }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n        options = assign(false, options);\n        Object.keys(socketOptions).forEach(key => {\n          options[key] = socketOptions[key];\n        });\n      }\n      this.connection = new SMTPConnection(options);\n      this.connection.once('error', err => {\n        this.emit('error', err);\n        if (returned) {\n          return;\n        }\n        returned = true;\n        return callback(err);\n      });\n      this.connection.once('end', () => {\n        this.close();\n        if (returned) {\n          return;\n        }\n        returned = true;\n        let timer = setTimeout(() => {\n          if (returned) {\n            return;\n          }\n          // still have not returned, this means we have an unexpected connection close\n          let err = new Error('Unexpected socket close');\n          if (this.connection && this.connection._socket && this.connection._socket.upgrading) {\n            // starttls connection errors\n            err.code = 'ETLS';\n          }\n          callback(err);\n        }, 1000);\n        try {\n          timer.unref();\n        } catch (E) {\n          // Ignore. Happens on envs with non-node timer implementation\n        }\n      });\n      this.connection.connect(() => {\n        if (returned) {\n          return;\n        }\n        if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {\n          this.connection.login(this.auth, err => {\n            if (returned) {\n              return;\n            }\n            returned = true;\n            if (err) {\n              this.connection.close();\n              this.emit('error', err);\n              return callback(err);\n            }\n            this._connected = true;\n            callback(null, true);\n          });\n        } else {\n          returned = true;\n          this._connected = true;\n          return callback(null, true);\n        }\n      });\n    });\n  }\n\n  /**\n   * Sends an e-mail to be sent using the selected settings\n   *\n   * @param {Object} mail Mail object\n   * @param {Function} callback Callback function\n   */\n  send(mail, callback) {\n    if (!this._connected) {\n      return this.connect(err => {\n        if (err) {\n          return callback(err);\n        }\n        return this.send(mail, callback);\n      });\n    }\n    let envelope = mail.message.getEnvelope();\n    let messageId = mail.message.messageId();\n    let recipients = [].concat(envelope.to || []);\n    if (recipients.length > 3) {\n      recipients.push('...and ' + recipients.splice(2).length + ' more');\n    }\n    this.logger.info({\n      tnx: 'send',\n      messageId,\n      cid: this.id\n    }, 'Sending message %s using #%s to <%s>', messageId, this.id, recipients.join(', '));\n    if (mail.data.dsn) {\n      envelope.dsn = mail.data.dsn;\n    }\n    this.connection.send(envelope, mail.message.createReadStream(), (err, info) => {\n      this.messages++;\n      if (err) {\n        this.connection.close();\n        this.emit('error', err);\n        return callback(err);\n      }\n      info.envelope = {\n        from: envelope.from,\n        to: envelope.to\n      };\n      info.messageId = messageId;\n      setImmediate(() => {\n        let err;\n        if (this.messages >= this.options.maxMessages) {\n          err = new Error('Resource exhausted');\n          err.code = 'EMAXLIMIT';\n          this.connection.close();\n          this.emit('error', err);\n        } else {\n          this.pool._checkRateLimit(() => {\n            this.available = true;\n            this.emit('available');\n          });\n        }\n      });\n      callback(null, info);\n    });\n  }\n\n  /**\n   * Closes the connection\n   */\n  close() {\n    this._connected = false;\n    if (this.auth && this.auth.oauth2) {\n      this.auth.oauth2.removeAllListeners();\n    }\n    if (this.connection) {\n      this.connection.close();\n    }\n    this.emit('close');\n  }\n}\nmodule.exports = PoolResource;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}