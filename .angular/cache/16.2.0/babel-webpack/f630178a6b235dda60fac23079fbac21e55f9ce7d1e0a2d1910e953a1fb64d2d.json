{"ast":null,"code":"import { Observable, of } from 'rxjs';\nimport { map, startWith, distinctUntilChanged, first, scan, switchMap, debounceTime, shareReplay } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/cdk/scrolling\";\n/** Returns an observable mirroring the source while running within the given zone */\nexport function runInZone(zone) {\n  return source => {\n    return new Observable(observer => {\n      return source.subscribe(value => zone.run(() => observer.next(value)), e => zone.run(() => observer.error(e)), () => zone.run(() => observer.complete()));\n    });\n  };\n}\nlet AnimateService = /*#__PURE__*/(() => {\n  var _class;\n  class AnimateService {\n    // By default, use the viewport rectangle\n    get viewRect() {\n      return this.viewPort.getViewportRect();\n    }\n    constructor(scroll, viewPort, zone) {\n      this.scroll = scroll;\n      this.viewPort = viewPort;\n      this.zone = zone;\n      // Tracks for viewport changes giving it 100ms time to accurately update for orientation changes\n      this.view$ = viewPort.change(100).pipe(startWith(null), map(() => this.viewRect), debounceTime(20),\n      // Makes all the component to share the same viewport values\n      shareReplay(1));\n    }\n    // Triggers the animation\n    trigger(elm, threshold) {\n      // Waits until the zone is stable once, aka the render is complete so the element to measure is there\n      return source => this.zone.onStable.pipe(\n      // Waits just once\n      first(),\n      // Triggers the play and replay requests\n      switchMap(() => source),\n      // Triggers the while scrolling\n      switchMap(trigger => threshold > 0 ? this.aos(elm, threshold) : of(trigger)));\n    }\n    // Triggers the animation on scroll\n    aos(elm, threshold) {\n      // A variation based on IntersectionObserver can be conditionally implemented here.\n      // Returns an AOS observable\n      return this.scroll.ancestorScrolled(elm, 0).pipe(\n      // Makes sure triggering the start no matter there's no scroll event hits yet\n      startWith(0),\n      // Maps the scrolling to the element visibility value\n      switchMap(() => this.visibility(elm)),\n      // Applies an hysteresys, so, to trigger the animation on based on the treshold while off on full invisibility\n      scan((result, visiblility) => visiblility >= threshold || result && visiblility > 0, false),\n      // Distincts the resulting triggers\n      distinctUntilChanged(),\n      // Runs within the angular zone to trigger change detection back on\n      runInZone(this.zone));\n    }\n    // Computes the element's visibility ratio against the viewport\n    visibility(elm) {\n      // Resolves from the latest viewport\n      return this.view$.pipe(map(view => {\n        // Gets the element's bounding rect\n        const rect = elm && elm.nativeElement && elm.nativeElement.getBoundingClientRect();\n        if (!rect) {\n          return 0;\n        }\n        // Return 1.0 when the element is fully within the viewport\n        if (rect.left > view.left - 1 && rect.top > view.top - 1 && rect.right < view.right + 1 && rect.bottom < view.bottom + 1) {\n          return 1;\n        }\n        // Computes the intersection area otherwise\n        const a = Math.round(rect.width * rect.height);\n        const b = Math.max(0, Math.min(rect.right, view.right) - Math.max(rect.left, view.left));\n        const c = Math.max(0, Math.min(rect.bottom, view.bottom) - Math.max(rect.top, view.top));\n        // Returns the amount of visible area\n        return Math.round(b * c / a * 10) / 10;\n      }));\n    }\n  }\n  _class = AnimateService;\n  _class.ɵfac = function AnimateService_Factory(t) {\n    return new (t || _class)(i0.ɵɵinject(i1.ScrollDispatcher), i0.ɵɵinject(i1.ViewportRuler), i0.ɵɵinject(i0.NgZone));\n  };\n  _class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac,\n    providedIn: 'root'\n  });\n  return AnimateService;\n})();\nexport { AnimateService };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}