{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer, 'utf-8');\n  }\n  return buffer.toString('base64');\n}\n\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n  if (str.length <= lineLength) {\n    return str;\n  }\n  let result = [];\n  let pos = 0;\n  let chunkLength = lineLength * 1024;\n  while (pos < str.length) {\n    let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n').trim();\n    result.push(wrappedLines);\n    pos += chunkLength;\n  }\n  return result.join('\\r\\n').trim();\n}\n\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n  constructor(options) {\n    super();\n    // init Transform\n    this.options = options || {};\n    if (this.options.lineLength !== false) {\n      this.options.lineLength = this.options.lineLength || 76;\n    }\n    this._curLine = '';\n    this._remainingBytes = false;\n    this.inputBytes = 0;\n    this.outputBytes = 0;\n  }\n  _transform(chunk, encoding, done) {\n    if (encoding !== 'buffer') {\n      chunk = Buffer.from(chunk, encoding);\n    }\n    if (!chunk || !chunk.length) {\n      return setImmediate(done);\n    }\n    this.inputBytes += chunk.length;\n    if (this._remainingBytes && this._remainingBytes.length) {\n      chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);\n      this._remainingBytes = false;\n    }\n    if (chunk.length % 3) {\n      this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);\n      chunk = chunk.slice(0, chunk.length - chunk.length % 3);\n    } else {\n      this._remainingBytes = false;\n    }\n    let b64 = this._curLine + encode(chunk);\n    if (this.options.lineLength) {\n      b64 = wrap(b64, this.options.lineLength);\n\n      // remove last line as it is still most probably incomplete\n      let lastLF = b64.lastIndexOf('\\n');\n      if (lastLF < 0) {\n        this._curLine = b64;\n        b64 = '';\n      } else if (lastLF === b64.length - 1) {\n        this._curLine = '';\n      } else {\n        this._curLine = b64.substr(lastLF + 1);\n        b64 = b64.substr(0, lastLF + 1);\n      }\n    }\n    if (b64) {\n      this.outputBytes += b64.length;\n      this.push(Buffer.from(b64, 'ascii'));\n    }\n    setImmediate(done);\n  }\n  _flush(done) {\n    if (this._remainingBytes && this._remainingBytes.length) {\n      this._curLine += encode(this._remainingBytes);\n    }\n    if (this._curLine) {\n      this._curLine = wrap(this._curLine, this.options.lineLength);\n      this.outputBytes += this._curLine.length;\n      this.push(this._curLine, 'ascii');\n      this._curLine = '';\n    }\n    done();\n  }\n}\n\n// expose to the world\nmodule.exports = {\n  encode,\n  wrap,\n  Encoder\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}