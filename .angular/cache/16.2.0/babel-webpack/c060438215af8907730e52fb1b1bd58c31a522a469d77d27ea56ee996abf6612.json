{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst shared = require('../shared');\nconst mimeTypes = require('../mime-funcs/mime-types');\nconst MailComposer = require('../mail-composer');\nconst DKIM = require('../dkim');\nconst httpProxyClient = require('../smtp-connection/http-proxy-client');\nconst util = require('util');\nconst urllib = require('url');\nconst packageData = require('../../package.json');\nconst MailMessage = require('./mail-message');\nconst net = require('net');\nconst dns = require('dns');\nconst crypto = require('crypto');\n\n/**\n * Creates an object for exposing the Mail API\n *\n * @constructor\n * @param {Object} transporter Transport object instance to pass the mails to\n */\nclass Mail extends EventEmitter {\n  constructor(transporter, options, defaults) {\n    super();\n    this.options = options || {};\n    this._defaults = defaults || {};\n    this._defaultPlugins = {\n      compile: [(...args) => this._convertDataImages(...args)],\n      stream: []\n    };\n    this._userPlugins = {\n      compile: [],\n      stream: []\n    };\n    this.meta = new Map();\n    this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;\n    this.transporter = transporter;\n    this.transporter.mailer = this;\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'mail'\n    });\n    this.logger.debug({\n      tnx: 'create'\n    }, 'Creating transport: %s', this.getVersionString());\n\n    // setup emit handlers for the transporter\n    if (typeof this.transporter.on === 'function') {\n      // deprecated log interface\n      this.transporter.on('log', log => {\n        this.logger.debug({\n          tnx: 'transport'\n        }, '%s: %s', log.type, log.message);\n      });\n\n      // transporter errors\n      this.transporter.on('error', err => {\n        this.logger.error({\n          err,\n          tnx: 'transport'\n        }, 'Transport Error: %s', err.message);\n        this.emit('error', err);\n      });\n\n      // indicates if the sender has became idle\n      this.transporter.on('idle', (...args) => {\n        this.emit('idle', ...args);\n      });\n    }\n\n    /**\n     * Optional methods passed to the underlying transport object\n     */\n    ['close', 'isIdle', 'verify'].forEach(method => {\n      this[method] = (...args) => {\n        if (typeof this.transporter[method] === 'function') {\n          if (method === 'verify' && typeof this.getSocket === 'function') {\n            this.transporter.getSocket = this.getSocket;\n            this.getSocket = false;\n          }\n          return this.transporter[method](...args);\n        } else {\n          this.logger.warn({\n            tnx: 'transport',\n            methodName: method\n          }, 'Non existing method %s called for transport', method);\n          return false;\n        }\n      };\n    });\n\n    // setup proxy handling\n    if (this.options.proxy && typeof this.options.proxy === 'string') {\n      this.setupProxy(this.options.proxy);\n    }\n  }\n  use(step, plugin) {\n    step = (step || '').toString();\n    if (!this._userPlugins.hasOwnProperty(step)) {\n      this._userPlugins[step] = [plugin];\n    } else {\n      this._userPlugins[step].push(plugin);\n    }\n    return this;\n  }\n\n  /**\n   * Sends an email using the preselected transport object\n   *\n   * @param {Object} data E-data description\n   * @param {Function?} callback Callback to run once the sending succeeded or failed\n   */\n  sendMail(data, callback = null) {\n    let promise;\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n    if (typeof this.getSocket === 'function') {\n      this.transporter.getSocket = this.getSocket;\n      this.getSocket = false;\n    }\n    let mail = new MailMessage(this, data);\n    this.logger.debug({\n      tnx: 'transport',\n      name: this.transporter.name,\n      version: this.transporter.version,\n      action: 'send'\n    }, 'Sending mail using %s/%s', this.transporter.name, this.transporter.version);\n    this._processPlugins('compile', mail, err => {\n      if (err) {\n        this.logger.error({\n          err,\n          tnx: 'plugin',\n          action: 'compile'\n        }, 'PluginCompile Error: %s', err.message);\n        return callback(err);\n      }\n      mail.message = new MailComposer(mail.data).compile();\n      mail.setMailerHeader();\n      mail.setPriorityHeaders();\n      mail.setListHeaders();\n      this._processPlugins('stream', mail, err => {\n        if (err) {\n          this.logger.error({\n            err,\n            tnx: 'plugin',\n            action: 'stream'\n          }, 'PluginStream Error: %s', err.message);\n          return callback(err);\n        }\n        if (mail.data.dkim || this.dkim) {\n          mail.message.processFunc(input => {\n            let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;\n            this.logger.debug({\n              tnx: 'DKIM',\n              messageId: mail.message.messageId(),\n              dkimDomains: dkim.keys.map(key => key.keySelector + '.' + key.domainName).join(', ')\n            }, 'Signing outgoing message with %s keys', dkim.keys.length);\n            return dkim.sign(input, mail.data._dkim);\n          });\n        }\n        this.transporter.send(mail, (...args) => {\n          if (args[0]) {\n            this.logger.error({\n              err: args[0],\n              tnx: 'transport',\n              action: 'send'\n            }, 'Send Error: %s', args[0].message);\n          }\n          callback(...args);\n        });\n      });\n    });\n    return promise;\n  }\n  getVersionString() {\n    return util.format('%s (%s; +%s; %s/%s)', packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);\n  }\n  _processPlugins(step, mail, callback) {\n    step = (step || '').toString();\n    if (!this._userPlugins.hasOwnProperty(step)) {\n      return callback();\n    }\n    let userPlugins = this._userPlugins[step] || [];\n    let defaultPlugins = this._defaultPlugins[step] || [];\n    if (userPlugins.length) {\n      this.logger.debug({\n        tnx: 'transaction',\n        pluginCount: userPlugins.length,\n        step\n      }, 'Using %s plugins for %s', userPlugins.length, step);\n    }\n    if (userPlugins.length + defaultPlugins.length === 0) {\n      return callback();\n    }\n    let pos = 0;\n    let block = 'default';\n    let processPlugins = () => {\n      let curplugins = block === 'default' ? defaultPlugins : userPlugins;\n      if (pos >= curplugins.length) {\n        if (block === 'default' && userPlugins.length) {\n          block = 'user';\n          pos = 0;\n          curplugins = userPlugins;\n        } else {\n          return callback();\n        }\n      }\n      let plugin = curplugins[pos++];\n      plugin(mail, err => {\n        if (err) {\n          return callback(err);\n        }\n        processPlugins();\n      });\n    };\n    processPlugins();\n  }\n\n  /**\n   * Sets up proxy handler for a Nodemailer object\n   *\n   * @param {String} proxyUrl Proxy configuration url\n   */\n  setupProxy(proxyUrl) {\n    let proxy = urllib.parse(proxyUrl);\n\n    // setup socket handler for the mailer object\n    this.getSocket = (options, callback) => {\n      let protocol = proxy.protocol.replace(/:$/, '').toLowerCase();\n      if (this.meta.has('proxy_handler_' + protocol)) {\n        return this.meta.get('proxy_handler_' + protocol)(proxy, options, callback);\n      }\n      switch (protocol) {\n        // Connect using a HTTP CONNECT method\n        case 'http':\n        case 'https':\n          httpProxyClient(proxy.href, options.port, options.host, (err, socket) => {\n            if (err) {\n              return callback(err);\n            }\n            return callback(null, {\n              connection: socket\n            });\n          });\n          return;\n        case 'socks':\n        case 'socks5':\n        case 'socks4':\n        case 'socks4a':\n          {\n            if (!this.meta.has('proxy_socks_module')) {\n              return callback(new Error('Socks module not loaded'));\n            }\n            let connect = ipaddress => {\n              let proxyV2 = !!this.meta.get('proxy_socks_module').SocksClient;\n              let socksClient = proxyV2 ? this.meta.get('proxy_socks_module').SocksClient : this.meta.get('proxy_socks_module');\n              let proxyType = Number(proxy.protocol.replace(/\\D/g, '')) || 5;\n              let connectionOpts = {\n                proxy: {\n                  ipaddress,\n                  port: Number(proxy.port),\n                  type: proxyType\n                },\n                [proxyV2 ? 'destination' : 'target']: {\n                  host: options.host,\n                  port: options.port\n                },\n                command: 'connect'\n              };\n              if (proxy.auth) {\n                let username = decodeURIComponent(proxy.auth.split(':').shift());\n                let password = decodeURIComponent(proxy.auth.split(':').pop());\n                if (proxyV2) {\n                  connectionOpts.proxy.userId = username;\n                  connectionOpts.proxy.password = password;\n                } else if (proxyType === 4) {\n                  connectionOpts.userid = username;\n                } else {\n                  connectionOpts.authentication = {\n                    username,\n                    password\n                  };\n                }\n              }\n              socksClient.createConnection(connectionOpts, (err, info) => {\n                if (err) {\n                  return callback(err);\n                }\n                return callback(null, {\n                  connection: info.socket || info\n                });\n              });\n            };\n            if (net.isIP(proxy.hostname)) {\n              return connect(proxy.hostname);\n            }\n            return dns.resolve(proxy.hostname, (err, address) => {\n              if (err) {\n                return callback(err);\n              }\n              connect(Array.isArray(address) ? address[0] : address);\n            });\n          }\n      }\n      callback(new Error('Unknown proxy configuration'));\n    };\n  }\n  _convertDataImages(mail, callback) {\n    if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {\n      return callback();\n    }\n    mail.resolveContent(mail.data, 'html', (err, html) => {\n      if (err) {\n        return callback(err);\n      }\n      let cidCounter = 0;\n      html = (html || '').toString().replace(/(<img\\b[^>]* src\\s*=[\\s\"']*)(data:([^;]+);[^\"'>\\s]+)/gi, (match, prefix, dataUri, mimeType) => {\n        let cid = crypto.randomBytes(10).toString('hex') + '@localhost';\n        if (!mail.data.attachments) {\n          mail.data.attachments = [];\n        }\n        if (!Array.isArray(mail.data.attachments)) {\n          mail.data.attachments = [].concat(mail.data.attachments || []);\n        }\n        mail.data.attachments.push({\n          path: dataUri,\n          cid,\n          filename: 'image-' + ++cidCounter + '.' + mimeTypes.detectExtension(mimeType)\n        });\n        return prefix + 'cid:' + cid;\n      });\n      mail.data.html = html;\n      callback();\n    });\n  }\n  set(key, value) {\n    return this.meta.set(key, value);\n  }\n  get(key) {\n    return this.meta.get(key);\n  }\n}\nmodule.exports = Mail;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}