{"ast":null,"code":"'use strict';\n\nconst spawn = require('child_process').spawn;\nconst packageData = require('../../package.json');\nconst shared = require('../shared');\n\n/**\n * Generates a Transport object for Sendmail\n *\n * Possible options can be the following:\n *\n *  * **path** optional path to sendmail binary\n *  * **newline** either 'windows' or 'unix'\n *  * **args** an array of arguments for the sendmail binary\n *\n * @constructor\n * @param {Object} optional config parameter for Sendmail\n */\nclass SendmailTransport {\n  constructor(options) {\n    options = options || {};\n\n    // use a reference to spawn for mocking purposes\n    this._spawn = spawn;\n    this.options = options || {};\n    this.name = 'Sendmail';\n    this.version = packageData.version;\n    this.path = 'sendmail';\n    this.args = false;\n    this.winbreak = false;\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'sendmail'\n    });\n    if (options) {\n      if (typeof options === 'string') {\n        this.path = options;\n      } else if (typeof options === 'object') {\n        if (options.path) {\n          this.path = options.path;\n        }\n        if (Array.isArray(options.args)) {\n          this.args = options.args;\n        }\n        this.winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes((options.newline || '').toString().toLowerCase());\n      }\n    }\n  }\n\n  /**\n   * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>\n   *\n   * @param {Object} emailMessage MailComposer object\n   * @param {Function} callback Callback function to run when the sending is completed\n   */\n  send(mail, done) {\n    // Sendmail strips this header line by itself\n    mail.message.keepBcc = true;\n    let envelope = mail.data.envelope || mail.message.getEnvelope();\n    let messageId = mail.message.messageId();\n    let args;\n    let sendmail;\n    let returned;\n    const hasInvalidAddresses = [].concat(envelope.from || []).concat(envelope.to || []).some(addr => /^-/.test(addr));\n    if (hasInvalidAddresses) {\n      return done(new Error('Can not send mail. Invalid envelope addresses.'));\n    }\n    if (this.args) {\n      // force -i to keep single dots\n      args = ['-i'].concat(this.args).concat(envelope.to);\n    } else {\n      args = ['-i'].concat(envelope.from ? ['-f', envelope.from] : []).concat(envelope.to);\n    }\n    let callback = err => {\n      if (returned) {\n        // ignore any additional responses, already done\n        return;\n      }\n      returned = true;\n      if (typeof done === 'function') {\n        if (err) {\n          return done(err);\n        } else {\n          return done(null, {\n            envelope: mail.data.envelope || mail.message.getEnvelope(),\n            messageId,\n            response: 'Messages queued for delivery'\n          });\n        }\n      }\n    };\n    try {\n      sendmail = this._spawn(this.path, args);\n    } catch (E) {\n      this.logger.error({\n        err: E,\n        tnx: 'spawn',\n        messageId\n      }, 'Error occurred while spawning sendmail. %s', E.message);\n      return callback(E);\n    }\n    if (sendmail) {\n      sendmail.on('error', err => {\n        this.logger.error({\n          err,\n          tnx: 'spawn',\n          messageId\n        }, 'Error occurred when sending message %s. %s', messageId, err.message);\n        callback(err);\n      });\n      sendmail.once('exit', code => {\n        if (!code) {\n          return callback();\n        }\n        let err;\n        if (code === 127) {\n          err = new Error('Sendmail command not found, process exited with code ' + code);\n        } else {\n          err = new Error('Sendmail exited with code ' + code);\n        }\n        this.logger.error({\n          err,\n          tnx: 'stdin',\n          messageId\n        }, 'Error sending message %s to sendmail. %s', messageId, err.message);\n        callback(err);\n      });\n      sendmail.once('close', callback);\n      sendmail.stdin.on('error', err => {\n        this.logger.error({\n          err,\n          tnx: 'stdin',\n          messageId\n        }, 'Error occurred when piping message %s to sendmail. %s', messageId, err.message);\n        callback(err);\n      });\n      let recipients = [].concat(envelope.to || []);\n      if (recipients.length > 3) {\n        recipients.push('...and ' + recipients.splice(2).length + ' more');\n      }\n      this.logger.info({\n        tnx: 'send',\n        messageId\n      }, 'Sending message %s to <%s>', messageId, recipients.join(', '));\n      let sourceStream = mail.message.createReadStream();\n      sourceStream.once('error', err => {\n        this.logger.error({\n          err,\n          tnx: 'stdin',\n          messageId\n        }, 'Error occurred when generating message %s. %s', messageId, err.message);\n        sendmail.kill('SIGINT'); // do not deliver the message\n        callback(err);\n      });\n      sourceStream.pipe(sendmail.stdin);\n    } else {\n      return callback(new Error('sendmail was not found'));\n    }\n  }\n}\nmodule.exports = SendmailTransport;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}