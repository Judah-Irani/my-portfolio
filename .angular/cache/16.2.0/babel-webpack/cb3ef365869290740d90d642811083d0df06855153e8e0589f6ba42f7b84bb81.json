{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst packageData = require('../../package.json');\nconst shared = require('../shared');\nconst LeWindows = require('../mime-node/le-windows');\n\n/**\n * Generates a Transport object for AWS SES\n *\n * Possible options can be the following:\n *\n *  * **sendingRate** optional Number specifying how many messages per second should be delivered to SES\n *  * **maxConnections** optional Number specifying max number of parallel connections to SES\n *\n * @constructor\n * @param {Object} optional config parameter\n */\nclass SESTransport extends EventEmitter {\n  constructor(options) {\n    super();\n    options = options || {};\n    this.options = options || {};\n    this.ses = this.options.SES;\n    this.name = 'SESTransport';\n    this.version = packageData.version;\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'ses-transport'\n    });\n\n    // parallel sending connections\n    this.maxConnections = Number(this.options.maxConnections) || Infinity;\n    this.connections = 0;\n\n    // max messages per second\n    this.sendingRate = Number(this.options.sendingRate) || Infinity;\n    this.sendingRateTTL = null;\n    this.rateInterval = 1000; // milliseconds\n    this.rateMessages = [];\n    this.pending = [];\n    this.idling = true;\n    setImmediate(() => {\n      if (this.idling) {\n        this.emit('idle');\n      }\n    });\n  }\n\n  /**\n   * Schedules a sending of a message\n   *\n   * @param {Object} emailMessage MailComposer object\n   * @param {Function} callback Callback function to run when the sending is completed\n   */\n  send(mail, callback) {\n    if (this.connections >= this.maxConnections) {\n      this.idling = false;\n      return this.pending.push({\n        mail,\n        callback\n      });\n    }\n    if (!this._checkSendingRate()) {\n      this.idling = false;\n      return this.pending.push({\n        mail,\n        callback\n      });\n    }\n    this._send(mail, (...args) => {\n      setImmediate(() => callback(...args));\n      this._sent();\n    });\n  }\n  _checkRatedQueue() {\n    if (this.connections >= this.maxConnections || !this._checkSendingRate()) {\n      return;\n    }\n    if (!this.pending.length) {\n      if (!this.idling) {\n        this.idling = true;\n        this.emit('idle');\n      }\n      return;\n    }\n    let next = this.pending.shift();\n    this._send(next.mail, (...args) => {\n      setImmediate(() => next.callback(...args));\n      this._sent();\n    });\n  }\n  _checkSendingRate() {\n    clearTimeout(this.sendingRateTTL);\n    let now = Date.now();\n    let oldest = false;\n    // delete older messages\n    for (let i = this.rateMessages.length - 1; i >= 0; i--) {\n      if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {\n        oldest = this.rateMessages[i].ts;\n      }\n      if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {\n        this.rateMessages.splice(i, 1);\n      }\n    }\n    if (this.rateMessages.length < this.sendingRate) {\n      return true;\n    }\n    let delay = Math.max(oldest + 1001, now + 20);\n    this.sendingRateTTL = setTimeout(() => this._checkRatedQueue(), now - delay);\n    try {\n      this.sendingRateTTL.unref();\n    } catch (E) {\n      // Ignore. Happens on envs with non-node timer implementation\n    }\n    return false;\n  }\n  _sent() {\n    this.connections--;\n    this._checkRatedQueue();\n  }\n\n  /**\n   * Returns true if there are free slots in the queue\n   */\n  isIdle() {\n    return this.idling;\n  }\n\n  /**\n   * Compiles a mailcomposer message and forwards it to SES\n   *\n   * @param {Object} emailMessage MailComposer object\n   * @param {Function} callback Callback function to run when the sending is completed\n   */\n  _send(mail, callback) {\n    let statObject = {\n      ts: Date.now(),\n      pending: true\n    };\n    this.connections++;\n    this.rateMessages.push(statObject);\n    let envelope = mail.data.envelope || mail.message.getEnvelope();\n    let messageId = mail.message.messageId();\n    let recipients = [].concat(envelope.to || []);\n    if (recipients.length > 3) {\n      recipients.push('...and ' + recipients.splice(2).length + ' more');\n    }\n    this.logger.info({\n      tnx: 'send',\n      messageId\n    }, 'Sending message %s to <%s>', messageId, recipients.join(', '));\n    let getRawMessage = next => {\n      // do not use Message-ID and Date in DKIM signature\n      if (!mail.data._dkim) {\n        mail.data._dkim = {};\n      }\n      if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === 'string') {\n        mail.data._dkim.skipFields += ':date:message-id';\n      } else {\n        mail.data._dkim.skipFields = 'date:message-id';\n      }\n      let sourceStream = mail.message.createReadStream();\n      let stream = sourceStream.pipe(new LeWindows());\n      let chunks = [];\n      let chunklen = 0;\n      stream.on('readable', () => {\n        let chunk;\n        while ((chunk = stream.read()) !== null) {\n          chunks.push(chunk);\n          chunklen += chunk.length;\n        }\n      });\n      sourceStream.once('error', err => stream.emit('error', err));\n      stream.once('error', err => {\n        next(err);\n      });\n      stream.once('end', () => next(null, Buffer.concat(chunks, chunklen)));\n    };\n    setImmediate(() => getRawMessage((err, raw) => {\n      if (err) {\n        this.logger.error({\n          err,\n          tnx: 'send',\n          messageId\n        }, 'Failed creating message for %s. %s', messageId, err.message);\n        statObject.pending = false;\n        return callback(err);\n      }\n      let sesMessage = {\n        RawMessage: {\n          // required\n          Data: raw // required\n        },\n\n        Source: envelope.from,\n        Destinations: envelope.to\n      };\n      Object.keys(mail.data.ses || {}).forEach(key => {\n        sesMessage[key] = mail.data.ses[key];\n      });\n      let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};\n      let aws = this.ses.aws || {};\n      let getRegion = cb => {\n        if (ses.config && typeof ses.config.region === 'function') {\n          // promise\n          return ses.config.region().then(region => cb(null, region)).catch(err => cb(err));\n        }\n        return cb(null, ses.config && ses.config.region || 'us-east-1');\n      };\n      getRegion((err, region) => {\n        if (err || !region) {\n          region = 'us-east-1';\n        }\n        let sendPromise;\n        if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {\n          // v3 API\n          sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));\n        } else {\n          // v2 API\n          sendPromise = ses.sendRawEmail(sesMessage).promise();\n        }\n        sendPromise.then(data => {\n          if (region === 'us-east-1') {\n            region = 'email';\n          }\n          statObject.pending = false;\n          callback(null, {\n            envelope: {\n              from: envelope.from,\n              to: envelope.to\n            },\n            messageId: '<' + data.MessageId + (!/@/.test(data.MessageId) ? '@' + region + '.amazonses.com' : '') + '>',\n            response: data.MessageId,\n            raw\n          });\n        }).catch(err => {\n          this.logger.error({\n            err,\n            tnx: 'send'\n          }, 'Send error for %s: %s', messageId, err.message);\n          statObject.pending = false;\n          callback(err);\n        });\n      });\n    }));\n  }\n\n  /**\n   * Verifies SES configuration\n   *\n   * @param {Function} callback Callback function\n   */\n  verify(callback) {\n    let promise;\n    let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};\n    let aws = this.ses.aws || {};\n    const sesMessage = {\n      RawMessage: {\n        // required\n        Data: 'From: invalid@invalid\\r\\nTo: invalid@invalid\\r\\n Subject: Invalid\\r\\n\\r\\nInvalid'\n      },\n      Source: 'invalid@invalid',\n      Destinations: ['invalid@invalid']\n    };\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n    const cb = err => {\n      if (err && (err.code || err.Code) !== 'InvalidParameterValue') {\n        return callback(err);\n      }\n      return callback(null, true);\n    };\n    if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {\n      // v3 API\n      sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);\n      ses.send(new aws.SendRawEmailCommand(sesMessage), cb);\n    } else {\n      // v2 API\n      ses.sendRawEmail(sesMessage, cb);\n    }\n    return promise;\n  }\n}\nmodule.exports = SESTransport;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}