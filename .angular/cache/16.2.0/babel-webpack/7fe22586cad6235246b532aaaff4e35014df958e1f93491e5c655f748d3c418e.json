{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { startWith, delay, filter, takeWhile } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport { trigger } from '@angular/animations';\n// Animations\nimport { beat, bounce, headShake, heartBeat, pulse, rubberBand, shake, swing, wobble, jello, tada, flip } from './attention-seekers';\nimport { bumpIn, bounceIn, fadeIn, flipIn, jackInTheBox, landing, rollIn, zoomIn } from './entrances';\nimport { bounceOut, fadeOut, hinge, rollOut, zoomOut } from './exits';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./animate.service\";\nconst _c0 = [\"wmAnimate\", \"\"];\nconst _c1 = [\"*\"];\nlet AnimateComponent = /*#__PURE__*/(() => {\n  var _class;\n  class AnimateComponent {\n    constructor(elm, scroll) {\n      this.elm = elm;\n      this.scroll = scroll;\n      this.replay$ = new Subject();\n      // Animating properties\n      this.animating = false;\n      this.animated = false;\n      this.disabled = false;\n      /** Emits at the end of the animation */\n      this.start = new EventEmitter();\n      /** Emits at the end of the animation */\n      this.done = new EventEmitter();\n      this.paused = false;\n      this.threshold = 0;\n      this.once = false;\n    }\n    get idle() {\n      return {\n        value: `idle-${this.animate}`\n      };\n    }\n    get play() {\n      const params = {};\n      // Builds the params object, so, leaving to the default values when undefined\n      if (!!this.timing) {\n        params['timing'] = this.timing;\n      }\n      if (!!this.delay) {\n        params['delay'] = this.delay;\n      }\n      return {\n        value: this.animate,\n        params\n      };\n    }\n    /** Speeds up or slows down the animation */\n    set speed(speed) {\n      // Turns the requested speed into a valid timing\n      this.timing = {\n        slower: '3s',\n        slow: '2s',\n        normal: '1s',\n        fast: '500ms',\n        faster: '300ms'\n      }[speed || 'normal'];\n    }\n    /** Delays the animation */\n    set postpone(delay) {\n      // Coerces the input into a number first\n      const value = coerceNumberProperty(delay, 0);\n      if (value) {\n        // Turns a valid number into a ms delay\n        this.delay = `${value}ms`;\n      } else {\n        // Test the string for a valid delay combination\n        this.delay = /^\\d+(?:ms|s)$/.test(delay) ? delay : '';\n      }\n    }\n    /** Disables the animation */\n    set disableAnimation(value) {\n      this.disabled = coerceBooleanProperty(value);\n    }\n    animationStart() {\n      this.animating = true;\n      this.animated = false;\n      this.start.emit();\n    }\n    animationDone() {\n      this.animating = false;\n      this.animated = true;\n      this.done.emit();\n    }\n    /** When true, keeps the animation idle until the next replay triggers */\n    set pauseAnimation(value) {\n      this.paused = coerceBooleanProperty(value);\n    }\n    /** When defined, triggers the animation on element scrolling in the viewport by the specified amount. Amount defaults to 50% when not specified */\n    set enableAOS(value) {\n      this.threshold = coerceNumberProperty(value, 0.5);\n    }\n    /** When true, triggers the animation on element scrolling in the viewport */\n    set aosOnce(value) {\n      this.once = coerceBooleanProperty(value);\n    }\n    /** Replays the animation */\n    set replay(replay) {\n      // Re-triggers the animation again on request (skipping the very fist value)\n      if (!!this.trigger && coerceBooleanProperty(replay)) {\n        this.trigger = this.idle;\n        this.replay$.next(true);\n      }\n    }\n    ngOnInit() {\n      // Sets the idle state for the given animation\n      this.trigger = this.idle;\n      // Triggers the animation based on the input flags\n      this.sub = this.replay$.pipe(\n      // Waits the next round to re-trigger\n      delay(0),\n      // Triggers immediately when not paused\n      startWith(!this.paused),\n      // Builds the AOS observable from the common service\n      this.scroll.trigger(this.elm, this.threshold),\n      // Prevents false visibility blinks due to the animation transformations\n      filter(trigger => !this.animating),\n      // Stops after the first on trigger when 'once' is set\n      takeWhile(trigger => !trigger || !this.once, true)).subscribe(trigger => {\n        // Triggers the animation to play or to idle\n        this.trigger = trigger ? this.play : this.idle;\n      });\n    }\n    ngOnDestroy() {\n      this.sub.unsubscribe();\n    }\n  }\n  _class = AnimateComponent;\n  _class.ɵfac = function AnimateComponent_Factory(t) {\n    return new (t || _class)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.AnimateService));\n  };\n  _class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: _class,\n    selectors: [[\"\", \"wmAnimate\", \"\"]],\n    hostVars: 2,\n    hostBindings: function AnimateComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵsyntheticHostListener(\"@animate.start\", function AnimateComponent_animation_animate_start_HostBindingHandler() {\n          return ctx.animationStart();\n        })(\"@animate.done\", function AnimateComponent_animation_animate_done_HostBindingHandler() {\n          return ctx.animationDone();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵsyntheticHostProperty(\"@animate\", ctx.trigger)(\"@.disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      animate: [\"wmAnimate\", \"animate\"],\n      speed: \"speed\",\n      postpone: [\"delay\", \"postpone\"],\n      disableAnimation: [\"disabled\", \"disableAnimation\"],\n      pauseAnimation: [\"paused\", \"pauseAnimation\"],\n      enableAOS: [\"aos\", \"enableAOS\"],\n      aosOnce: [\"once\", \"aosOnce\"],\n      replay: \"replay\"\n    },\n    outputs: {\n      start: \"start\",\n      done: \"done\"\n    },\n    attrs: _c0,\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function AnimateComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    data: {\n      animation: [trigger('animate', [\n      // Attention seekers\n      ...beat, ...bounce, ...flip, ...headShake, ...heartBeat, ...jello, ...pulse, ...rubberBand, ...shake, ...swing, ...tada, ...wobble,\n      // Entrances\n      ...bumpIn, ...bounceIn, ...fadeIn, ...flipIn, ...jackInTheBox, ...landing, ...rollIn, ...zoomIn,\n      // Exits\n      ...bounceOut, ...fadeOut, ...hinge, ...rollOut, ...zoomOut])]\n    }\n  });\n  return AnimateComponent;\n})();\nexport { AnimateComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}