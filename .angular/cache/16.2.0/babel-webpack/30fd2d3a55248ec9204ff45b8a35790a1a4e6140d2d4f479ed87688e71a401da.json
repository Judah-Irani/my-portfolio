{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst PoolResource = require('./pool-resource');\nconst SMTPConnection = require('../smtp-connection');\nconst wellKnown = require('../well-known');\nconst shared = require('../shared');\nconst packageData = require('../../package.json');\n\n/**\n * Creates a SMTP pool transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options SMTP Connection options\n */\nclass SMTPPool extends EventEmitter {\n  constructor(options) {\n    super();\n    options = options || {};\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n    let urlData;\n    let service = options.service;\n    if (typeof options.getSocket === 'function') {\n      this.getSocket = options.getSocket;\n    }\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n    this.options = shared.assign(false,\n    // create new object\n    options,\n    // regular options\n    urlData,\n    // url options\n    service && wellKnown(service) // wellknown options\n    );\n\n    this.options.maxConnections = this.options.maxConnections || 5;\n    this.options.maxMessages = this.options.maxMessages || 100;\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'smtp-pool'\n    });\n\n    // temporary object\n    let connection = new SMTPConnection(this.options);\n    this.name = 'SMTP (pool)';\n    this.version = packageData.version + '[client:' + connection.version + ']';\n    this._rateLimit = {\n      counter: 0,\n      timeout: null,\n      waiting: [],\n      checkpoint: false,\n      delta: Number(this.options.rateDelta) || 1000,\n      limit: Number(this.options.rateLimit) || 0\n    };\n    this._closed = false;\n    this._queue = [];\n    this._connections = [];\n    this._connectionCounter = 0;\n    this.idling = true;\n    setImmediate(() => {\n      if (this.idling) {\n        this.emit('idle');\n      }\n    });\n  }\n\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n  getSocket(options, callback) {\n    // return immediatelly\n    return setImmediate(() => callback(null, false));\n  }\n\n  /**\n   * Queues an e-mail to be sent using the selected settings\n   *\n   * @param {Object} mail Mail object\n   * @param {Function} callback Callback function\n   */\n  send(mail, callback) {\n    if (this._closed) {\n      return false;\n    }\n    this._queue.push({\n      mail,\n      requeueAttempts: 0,\n      callback\n    });\n    if (this.idling && this._queue.length >= this.options.maxConnections) {\n      this.idling = false;\n    }\n    setImmediate(() => this._processMessages());\n    return true;\n  }\n\n  /**\n   * Closes all connections in the pool. If there is a message being sent, the connection\n   * is closed later\n   */\n  close() {\n    let connection;\n    let len = this._connections.length;\n    this._closed = true;\n\n    // clear rate limit timer if it exists\n    clearTimeout(this._rateLimit.timeout);\n    if (!len && !this._queue.length) {\n      return;\n    }\n\n    // remove all available connections\n    for (let i = len - 1; i >= 0; i--) {\n      if (this._connections[i] && this._connections[i].available) {\n        connection = this._connections[i];\n        connection.close();\n        this.logger.info({\n          tnx: 'connection',\n          cid: connection.id,\n          action: 'removed'\n        }, 'Connection #%s removed', connection.id);\n      }\n    }\n    if (len && !this._connections.length) {\n      this.logger.debug({\n        tnx: 'connection'\n      }, 'All connections removed');\n    }\n    if (!this._queue.length) {\n      return;\n    }\n\n    // make sure that entire queue would be cleaned\n    let invokeCallbacks = () => {\n      if (!this._queue.length) {\n        this.logger.debug({\n          tnx: 'connection'\n        }, 'Pending queue entries cleared');\n        return;\n      }\n      let entry = this._queue.shift();\n      if (entry && typeof entry.callback === 'function') {\n        try {\n          entry.callback(new Error('Connection pool was closed'));\n        } catch (E) {\n          this.logger.error({\n            err: E,\n            tnx: 'callback',\n            cid: connection.id\n          }, 'Callback error for #%s: %s', connection.id, E.message);\n        }\n      }\n      setImmediate(invokeCallbacks);\n    };\n    setImmediate(invokeCallbacks);\n  }\n\n  /**\n   * Check the queue and available connections. If there is a message to be sent and there is\n   * an available connection, then use this connection to send the mail\n   */\n  _processMessages() {\n    let connection;\n    let i, len;\n\n    // do nothing if already closed\n    if (this._closed) {\n      return;\n    }\n\n    // do nothing if queue is empty\n    if (!this._queue.length) {\n      if (!this.idling) {\n        // no pending jobs\n        this.idling = true;\n        this.emit('idle');\n      }\n      return;\n    }\n\n    // find first available connection\n    for (i = 0, len = this._connections.length; i < len; i++) {\n      if (this._connections[i].available) {\n        connection = this._connections[i];\n        break;\n      }\n    }\n    if (!connection && this._connections.length < this.options.maxConnections) {\n      connection = this._createConnection();\n    }\n    if (!connection) {\n      // no more free connection slots available\n      this.idling = false;\n      return;\n    }\n\n    // check if there is free space in the processing queue\n    if (!this.idling && this._queue.length < this.options.maxConnections) {\n      this.idling = true;\n      this.emit('idle');\n    }\n    let entry = connection.queueEntry = this._queue.shift();\n    entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n    connection.available = false;\n    this.logger.debug({\n      tnx: 'pool',\n      cid: connection.id,\n      messageId: entry.messageId,\n      action: 'assign'\n    }, 'Assigned message <%s> to #%s (%s)', entry.messageId, connection.id, connection.messages + 1);\n    if (this._rateLimit.limit) {\n      this._rateLimit.counter++;\n      if (!this._rateLimit.checkpoint) {\n        this._rateLimit.checkpoint = Date.now();\n      }\n    }\n    connection.send(entry.mail, (err, info) => {\n      // only process callback if current handler is not changed\n      if (entry === connection.queueEntry) {\n        try {\n          entry.callback(err, info);\n        } catch (E) {\n          this.logger.error({\n            err: E,\n            tnx: 'callback',\n            cid: connection.id\n          }, 'Callback error for #%s: %s', connection.id, E.message);\n        }\n        connection.queueEntry = false;\n      }\n    });\n  }\n\n  /**\n   * Creates a new pool resource\n   */\n  _createConnection() {\n    let connection = new PoolResource(this);\n    connection.id = ++this._connectionCounter;\n    this.logger.info({\n      tnx: 'pool',\n      cid: connection.id,\n      action: 'conection'\n    }, 'Created new pool resource #%s', connection.id);\n\n    // resource comes available\n    connection.on('available', () => {\n      this.logger.debug({\n        tnx: 'connection',\n        cid: connection.id,\n        action: 'available'\n      }, 'Connection #%s became available', connection.id);\n      if (this._closed) {\n        // if already closed run close() that will remove this connections from connections list\n        this.close();\n      } else {\n        // check if there's anything else to send\n        this._processMessages();\n      }\n    });\n\n    // resource is terminated with an error\n    connection.once('error', err => {\n      if (err.code !== 'EMAXLIMIT') {\n        this.logger.error({\n          err,\n          tnx: 'pool',\n          cid: connection.id\n        }, 'Pool Error for #%s: %s', connection.id, err.message);\n      } else {\n        this.logger.debug({\n          tnx: 'pool',\n          cid: connection.id,\n          action: 'maxlimit'\n        }, 'Max messages limit exchausted for #%s', connection.id);\n      }\n      if (connection.queueEntry) {\n        try {\n          connection.queueEntry.callback(err);\n        } catch (E) {\n          this.logger.error({\n            err: E,\n            tnx: 'callback',\n            cid: connection.id\n          }, 'Callback error for #%s: %s', connection.id, E.message);\n        }\n        connection.queueEntry = false;\n      }\n\n      // remove the erroneus connection from connections list\n      this._removeConnection(connection);\n      this._continueProcessing();\n    });\n    connection.once('close', () => {\n      this.logger.info({\n        tnx: 'connection',\n        cid: connection.id,\n        action: 'closed'\n      }, 'Connection #%s was closed', connection.id);\n      this._removeConnection(connection);\n      if (connection.queueEntry) {\n        // If the connection closed when sending, add the message to the queue again\n        // if max number of requeues is not reached yet\n        // Note that we must wait a bit.. because the callback of the 'error' handler might be called\n        // in the next event loop\n        setTimeout(() => {\n          if (connection.queueEntry) {\n            if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {\n              this._requeueEntryOnConnectionClose(connection);\n            } else {\n              this._failDeliveryOnConnectionClose(connection);\n            }\n          }\n          this._continueProcessing();\n        }, 50);\n      } else {\n        this._continueProcessing();\n      }\n    });\n    this._connections.push(connection);\n    return connection;\n  }\n  _shouldRequeuOnConnectionClose(queueEntry) {\n    if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {\n      return true;\n    }\n    return queueEntry.requeueAttempts < this.options.maxRequeues;\n  }\n  _failDeliveryOnConnectionClose(connection) {\n    if (connection.queueEntry && connection.queueEntry.callback) {\n      try {\n        connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));\n      } catch (E) {\n        this.logger.error({\n          err: E,\n          tnx: 'callback',\n          messageId: connection.queueEntry.messageId,\n          cid: connection.id\n        }, 'Callback error for #%s: %s', connection.id, E.message);\n      }\n      connection.queueEntry = false;\n    }\n  }\n  _requeueEntryOnConnectionClose(connection) {\n    connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;\n    this.logger.debug({\n      tnx: 'pool',\n      cid: connection.id,\n      messageId: connection.queueEntry.messageId,\n      action: 'requeue'\n    }, 'Re-queued message <%s> for #%s. Attempt: #%s', connection.queueEntry.messageId, connection.id, connection.queueEntry.requeueAttempts);\n    this._queue.unshift(connection.queueEntry);\n    connection.queueEntry = false;\n  }\n\n  /**\n   * Continue to process message if the pool hasn't closed\n   */\n  _continueProcessing() {\n    if (this._closed) {\n      this.close();\n    } else {\n      setTimeout(() => this._processMessages(), 100);\n    }\n  }\n\n  /**\n   * Remove resource from pool\n   *\n   * @param {Object} connection The PoolResource to remove\n   */\n  _removeConnection(connection) {\n    let index = this._connections.indexOf(connection);\n    if (index !== -1) {\n      this._connections.splice(index, 1);\n    }\n  }\n\n  /**\n   * Checks if connections have hit current rate limit and if so, queues the availability callback\n   *\n   * @param {Function} callback Callback function to run once rate limiter has been cleared\n   */\n  _checkRateLimit(callback) {\n    if (!this._rateLimit.limit) {\n      return callback();\n    }\n    let now = Date.now();\n    if (this._rateLimit.counter < this._rateLimit.limit) {\n      return callback();\n    }\n    this._rateLimit.waiting.push(callback);\n    if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {\n      return this._clearRateLimit();\n    } else if (!this._rateLimit.timeout) {\n      this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));\n      this._rateLimit.checkpoint = now;\n    }\n  }\n\n  /**\n   * Clears current rate limit limitation and runs paused callback\n   */\n  _clearRateLimit() {\n    clearTimeout(this._rateLimit.timeout);\n    this._rateLimit.timeout = null;\n    this._rateLimit.counter = 0;\n    this._rateLimit.checkpoint = false;\n\n    // resume all paused connections\n    while (this._rateLimit.waiting.length) {\n      let cb = this._rateLimit.waiting.shift();\n      setImmediate(cb);\n    }\n  }\n\n  /**\n   * Returns true if there are free slots in the queue\n   */\n  isIdle() {\n    return this.idling;\n  }\n\n  /**\n   * Verifies SMTP configuration\n   *\n   * @param {Function} callback Callback function\n   */\n  verify(callback) {\n    let promise;\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n    let auth = new PoolResource(this).auth;\n    this.getSocket(this.options, (err, socketOptions) => {\n      if (err) {\n        return callback(err);\n      }\n      let options = this.options;\n      if (socketOptions && socketOptions.connection) {\n        this.logger.info({\n          tnx: 'proxy',\n          remoteAddress: socketOptions.connection.remoteAddress,\n          remotePort: socketOptions.connection.remotePort,\n          destHost: options.host || '',\n          destPort: options.port || '',\n          action: 'connected'\n        }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n        options = shared.assign(false, options);\n        Object.keys(socketOptions).forEach(key => {\n          options[key] = socketOptions[key];\n        });\n      }\n      let connection = new SMTPConnection(options);\n      let returned = false;\n      connection.once('error', err => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        connection.close();\n        return callback(err);\n      });\n      connection.once('end', () => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        return callback(new Error('Connection closed'));\n      });\n      let finalize = () => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        connection.quit();\n        return callback(null, true);\n      };\n      connection.connect(() => {\n        if (returned) {\n          return;\n        }\n        if (auth && (connection.allowsAuth || options.forceAuth)) {\n          connection.login(auth, err => {\n            if (returned) {\n              return;\n            }\n            if (err) {\n              returned = true;\n              connection.close();\n              return callback(err);\n            }\n            finalize();\n          });\n        } else if (!auth && connection.allowsAuth && options.forceAuth) {\n          let err = new Error('Authentication info was not provided');\n          err.code = 'NoAuth';\n          returned = true;\n          connection.close();\n          return callback(err);\n        } else {\n          finalize();\n        }\n      });\n    });\n    return promise;\n  }\n}\n\n// expose to the world\nmodule.exports = SMTPPool;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}