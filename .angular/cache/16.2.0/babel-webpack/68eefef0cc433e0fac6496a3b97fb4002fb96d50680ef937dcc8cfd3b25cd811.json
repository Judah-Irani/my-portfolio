{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst SMTPConnection = require('../smtp-connection');\nconst wellKnown = require('../well-known');\nconst shared = require('../shared');\nconst XOAuth2 = require('../xoauth2');\nconst packageData = require('../../package.json');\n\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\nclass SMTPTransport extends EventEmitter {\n  constructor(options) {\n    super();\n    options = options || {};\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n    let urlData;\n    let service = options.service;\n    if (typeof options.getSocket === 'function') {\n      this.getSocket = options.getSocket;\n    }\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n    this.options = shared.assign(false,\n    // create new object\n    options,\n    // regular options\n    urlData,\n    // url options\n    service && wellKnown(service) // wellknown options\n    );\n\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'smtp-transport'\n    });\n\n    // temporary object\n    let connection = new SMTPConnection(this.options);\n    this.name = 'SMTP';\n    this.version = packageData.version + '[client:' + connection.version + ']';\n    if (this.options.auth) {\n      this.auth = this.getAuth({});\n    }\n  }\n\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n  getSocket(options, callback) {\n    // return immediatelly\n    return setImmediate(() => callback(null, false));\n  }\n  getAuth(authOpts) {\n    if (!authOpts) {\n      return this.auth;\n    }\n    let hasAuth = false;\n    let authData = {};\n    if (this.options.auth && typeof this.options.auth === 'object') {\n      Object.keys(this.options.auth).forEach(key => {\n        hasAuth = true;\n        authData[key] = this.options.auth[key];\n      });\n    }\n    if (authOpts && typeof authOpts === 'object') {\n      Object.keys(authOpts).forEach(key => {\n        hasAuth = true;\n        authData[key] = authOpts[key];\n      });\n    }\n    if (!hasAuth) {\n      return false;\n    }\n    switch ((authData.type || '').toString().toUpperCase()) {\n      case 'OAUTH2':\n        {\n          if (!authData.service && !authData.user) {\n            return false;\n          }\n          let oauth2 = new XOAuth2(authData, this.logger);\n          oauth2.provisionCallback = this.mailer && this.mailer.get('oauth2_provision_cb') || oauth2.provisionCallback;\n          oauth2.on('token', token => this.mailer.emit('token', token));\n          oauth2.on('error', err => this.emit('error', err));\n          return {\n            type: 'OAUTH2',\n            user: authData.user,\n            oauth2,\n            method: 'XOAUTH2'\n          };\n        }\n      default:\n        return {\n          type: (authData.type || '').toString().toUpperCase() || 'LOGIN',\n          user: authData.user,\n          credentials: {\n            user: authData.user || '',\n            pass: authData.pass,\n            options: authData.options\n          },\n          method: (authData.method || '').trim().toUpperCase() || this.options.authMethod || false\n        };\n    }\n  }\n\n  /**\n   * Sends an e-mail using the selected settings\n   *\n   * @param {Object} mail Mail object\n   * @param {Function} callback Callback function\n   */\n  send(mail, callback) {\n    this.getSocket(this.options, (err, socketOptions) => {\n      if (err) {\n        return callback(err);\n      }\n      let returned = false;\n      let options = this.options;\n      if (socketOptions && socketOptions.connection) {\n        this.logger.info({\n          tnx: 'proxy',\n          remoteAddress: socketOptions.connection.remoteAddress,\n          remotePort: socketOptions.connection.remotePort,\n          destHost: options.host || '',\n          destPort: options.port || '',\n          action: 'connected'\n        }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n\n        // only copy options if we need to modify it\n        options = shared.assign(false, options);\n        Object.keys(socketOptions).forEach(key => {\n          options[key] = socketOptions[key];\n        });\n      }\n      let connection = new SMTPConnection(options);\n      connection.once('error', err => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        connection.close();\n        return callback(err);\n      });\n      connection.once('end', () => {\n        if (returned) {\n          return;\n        }\n        let timer = setTimeout(() => {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          // still have not returned, this means we have an unexpected connection close\n          let err = new Error('Unexpected socket close');\n          if (connection && connection._socket && connection._socket.upgrading) {\n            // starttls connection errors\n            err.code = 'ETLS';\n          }\n          callback(err);\n        }, 1000);\n        try {\n          timer.unref();\n        } catch (E) {\n          // Ignore. Happens on envs with non-node timer implementation\n        }\n      });\n      let sendMessage = () => {\n        let envelope = mail.message.getEnvelope();\n        let messageId = mail.message.messageId();\n        let recipients = [].concat(envelope.to || []);\n        if (recipients.length > 3) {\n          recipients.push('...and ' + recipients.splice(2).length + ' more');\n        }\n        if (mail.data.dsn) {\n          envelope.dsn = mail.data.dsn;\n        }\n        this.logger.info({\n          tnx: 'send',\n          messageId\n        }, 'Sending message %s to <%s>', messageId, recipients.join(', '));\n        connection.send(envelope, mail.message.createReadStream(), (err, info) => {\n          returned = true;\n          connection.close();\n          if (err) {\n            this.logger.error({\n              err,\n              tnx: 'send'\n            }, 'Send error for %s: %s', messageId, err.message);\n            return callback(err);\n          }\n          info.envelope = {\n            from: envelope.from,\n            to: envelope.to\n          };\n          info.messageId = messageId;\n          try {\n            return callback(null, info);\n          } catch (E) {\n            this.logger.error({\n              err: E,\n              tnx: 'callback'\n            }, 'Callback error for %s: %s', messageId, E.message);\n          }\n        });\n      };\n      connection.connect(() => {\n        if (returned) {\n          return;\n        }\n        let auth = this.getAuth(mail.data.auth);\n        if (auth && (connection.allowsAuth || options.forceAuth)) {\n          connection.login(auth, err => {\n            if (auth && auth !== this.auth && auth.oauth2) {\n              auth.oauth2.removeAllListeners();\n            }\n            if (returned) {\n              return;\n            }\n            if (err) {\n              returned = true;\n              connection.close();\n              return callback(err);\n            }\n            sendMessage();\n          });\n        } else {\n          sendMessage();\n        }\n      });\n    });\n  }\n\n  /**\n   * Verifies SMTP configuration\n   *\n   * @param {Function} callback Callback function\n   */\n  verify(callback) {\n    let promise;\n    if (!callback) {\n      promise = new Promise((resolve, reject) => {\n        callback = shared.callbackPromise(resolve, reject);\n      });\n    }\n    this.getSocket(this.options, (err, socketOptions) => {\n      if (err) {\n        return callback(err);\n      }\n      let options = this.options;\n      if (socketOptions && socketOptions.connection) {\n        this.logger.info({\n          tnx: 'proxy',\n          remoteAddress: socketOptions.connection.remoteAddress,\n          remotePort: socketOptions.connection.remotePort,\n          destHost: options.host || '',\n          destPort: options.port || '',\n          action: 'connected'\n        }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n        options = shared.assign(false, options);\n        Object.keys(socketOptions).forEach(key => {\n          options[key] = socketOptions[key];\n        });\n      }\n      let connection = new SMTPConnection(options);\n      let returned = false;\n      connection.once('error', err => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        connection.close();\n        return callback(err);\n      });\n      connection.once('end', () => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        return callback(new Error('Connection closed'));\n      });\n      let finalize = () => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        connection.quit();\n        return callback(null, true);\n      };\n      connection.connect(() => {\n        if (returned) {\n          return;\n        }\n        let authData = this.getAuth({});\n        if (authData && (connection.allowsAuth || options.forceAuth)) {\n          connection.login(authData, err => {\n            if (returned) {\n              return;\n            }\n            if (err) {\n              returned = true;\n              connection.close();\n              return callback(err);\n            }\n            finalize();\n          });\n        } else if (!authData && connection.allowsAuth && options.forceAuth) {\n          let err = new Error('Authentication info was not provided');\n          err.code = 'NoAuth';\n          returned = true;\n          connection.close();\n          return callback(err);\n        } else {\n          finalize();\n        }\n      });\n    });\n    return promise;\n  }\n\n  /**\n   * Releases resources\n   */\n  close() {\n    if (this.auth && this.auth.oauth2) {\n      this.auth.oauth2.removeAllListeners();\n    }\n    this.emit('close');\n  }\n}\n\n// expose to the world\nmodule.exports = SMTPTransport;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}