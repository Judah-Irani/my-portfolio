{"ast":null,"code":"'use strict';\n\n/**\n * Minimal HTTP/S proxy client\n */\nconst net = require('net');\nconst tls = require('tls');\nconst urllib = require('url');\n\n/**\n * Establishes proxied connection to destinationPort\n *\n * httpProxyClient(\"http://localhost:3128/\", 80, \"google.com\", function(err, socket){\n *     socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n * });\n *\n * @param {String} proxyUrl proxy configuration, etg \"http://proxy.host:3128/\"\n * @param {Number} destinationPort Port to open in destination host\n * @param {String} destinationHost Destination hostname\n * @param {Function} callback Callback to run with the rocket object once connection is established\n */\nfunction httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {\n  let proxy = urllib.parse(proxyUrl);\n\n  // create a socket connection to the proxy server\n  let options;\n  let connect;\n  let socket;\n  options = {\n    host: proxy.hostname,\n    port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80\n  };\n  if (proxy.protocol === 'https:') {\n    // we can use untrusted proxies as long as we verify actual SMTP certificates\n    options.rejectUnauthorized = false;\n    connect = tls.connect.bind(tls);\n  } else {\n    connect = net.connect.bind(net);\n  }\n\n  // Error harness for initial connection. Once connection is established, the responsibility\n  // to handle errors is passed to whoever uses this socket\n  let finished = false;\n  let tempSocketErr = err => {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    try {\n      socket.destroy();\n    } catch (E) {\n      // ignore\n    }\n    callback(err);\n  };\n  let timeoutErr = () => {\n    let err = new Error('Proxy socket timed out');\n    err.code = 'ETIMEDOUT';\n    tempSocketErr(err);\n  };\n  socket = connect(options, () => {\n    if (finished) {\n      return;\n    }\n    let reqHeaders = {\n      Host: destinationHost + ':' + destinationPort,\n      Connection: 'close'\n    };\n    if (proxy.auth) {\n      reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n    }\n    socket.write(\n    // HTTP method\n    'CONNECT ' + destinationHost + ':' + destinationPort + ' HTTP/1.1\\r\\n' +\n    // HTTP request headers\n    Object.keys(reqHeaders).map(key => key + ': ' + reqHeaders[key]).join('\\r\\n') +\n    // End request\n    '\\r\\n\\r\\n');\n    let headers = '';\n    let onSocketData = chunk => {\n      let match;\n      let remainder;\n      if (finished) {\n        return;\n      }\n      headers += chunk.toString('binary');\n      if (match = headers.match(/\\r\\n\\r\\n/)) {\n        socket.removeListener('data', onSocketData);\n        remainder = headers.substr(match.index + match[0].length);\n        headers = headers.substr(0, match.index);\n        if (remainder) {\n          socket.unshift(Buffer.from(remainder, 'binary'));\n        }\n\n        // proxy connection is now established\n        finished = true;\n\n        // check response code\n        match = headers.match(/^HTTP\\/\\d+\\.\\d+ (\\d+)/i);\n        if (!match || (match[1] || '').charAt(0) !== '2') {\n          try {\n            socket.destroy();\n          } catch (E) {\n            // ignore\n          }\n          return callback(new Error('Invalid response from proxy' + (match && ': ' + match[1] || '')));\n        }\n        socket.removeListener('error', tempSocketErr);\n        socket.removeListener('timeout', timeoutErr);\n        socket.setTimeout(0);\n        return callback(null, socket);\n      }\n    };\n    socket.on('data', onSocketData);\n  });\n  socket.setTimeout(httpProxyClient.timeout || 30 * 1000);\n  socket.on('timeout', timeoutErr);\n  socket.once('error', tempSocketErr);\n}\nmodule.exports = httpProxyClient;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}